{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project initialization and environment setup",
        "description": "Set up the TanStack Start project with TypeScript, configure build tools, and establish development environment with all necessary dependencies",
        "details": "Initialize a new TanStack Start project using the latest CLI (v1.x). Install core dependencies: @tanstack/start@latest, @tanstack/router@latest, vinxi@latest, typescript@5.3+. Set up package.json scripts for dev, build, and preview. Configure tsconfig.json with strict mode and path aliases. Create .env.example with placeholder keys for all services (CONVEX_URL, FIRECRAWL_API_KEY, SENTRY_DSN, AUTUMN_API_KEY, CLOUDFLARE_TURNSTILE_SECRET, GITHUB_WEBHOOK_SECRET). Initialize git repository with proper .gitignore (node_modules, .env, dist, .convex). Set up ESLint and Prettier with TanStack recommended configs.",
        "testStrategy": "Verify dev server starts successfully with `npm run dev`. Confirm TypeScript compilation with no errors. Test environment variable loading. Verify hot module replacement works.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize TanStack Start project using CLI",
            "description": "Create a new TanStack Start project using the official CLI and verify the initial project structure is properly scaffolded",
            "dependencies": [],
            "details": "Run `npx create-tanstack-start@latest` to initialize the project. Select TypeScript as the language option. Verify the generated directory structure includes app/, public/, and configuration files. Ensure the CLI creates a basic working application with default routes and components.\n<info added on 2025-11-09T11:14:19.088Z>\nSuccessfully initialized TanStack Start project structure:\n\nInstalled core dependencies:\n- @tanstack/start@1.120.20\n- @tanstack/router@0.0.1-beta.53 (will need update to v1.x in next subtask)\n- vinxi@0.5.8\n- react@19.2.0 & react-dom@19.2.0\n- vite@7.2.2\n\nCreated project structure:\n- app/ directory with routes/, components/, lib/ subdirectories\n- app/routes/__root.tsx (root layout with Outlet and devtools)\n- app/routes/index.tsx (home page with feature list)\n- app/client.tsx (client entry point with RouterProvider)\n- app/router.tsx (router configuration)\n- app/routeTree.gen.ts (generated route tree)\n- index.html (HTML entry point)\n- app.config.ts (TanStack Start configuration)\n- tsr.config.json (router generator configuration)\n- public/ directory for static assets\n\nConfigured package.json:\n- Set type: \"module\" for ES modules support\n- Added dev, build, start, routes, routes:watch scripts\n\nVersion compatibility issues identified between vinxi and router packages that require resolution in next subtask (dependency configuration).\n</info added on 2025-11-09T11:14:19.088Z>",
            "status": "done",
            "testStrategy": "Verify project directory exists with expected structure. Run initial dev server to confirm scaffolding works correctly."
          },
          {
            "id": 2,
            "title": "Install and configure core dependencies",
            "description": "Install required TanStack and TypeScript dependencies and verify compatibility",
            "dependencies": [
              1
            ],
            "details": "Install @tanstack/start@latest, @tanstack/router@latest, vinxi@latest, and typescript@5.3+ using npm or pnpm. Verify package.json contains correct versions. Check for any peer dependency warnings and resolve them. Ensure all packages install without errors.\n<info added on 2025-11-09T11:19:11.530Z>\nSuccessfully configured all core dependencies with TanStack Start v1.120.20, React Router v1.134.17, Vinxi v0.5.8, TypeScript v5.3.3, and Vite v7.2.2. Fixed initial compatibility issue where @tanstack/router@0.0.1-beta.53 was replaced with @tanstack/react-router@1.134.17 to match ecosystem versions. All peer dependencies resolved cleanly with no warnings. Dependency tree validated via npm list showing no conflicts. Development tooling configured with Router CLI v1.134.15, Router Devtools v1.134.17, and Router Generator v1.134.15.\n</info added on 2025-11-09T11:19:11.530Z>",
            "status": "done",
            "testStrategy": "Run `npm install` and verify no errors. Check package.json for correct versions. Run `npm list` to verify dependency tree is valid."
          },
          {
            "id": 3,
            "title": "Configure TypeScript with strict mode and path aliases",
            "description": "Set up tsconfig.json with strict TypeScript settings and configure path aliases for cleaner imports",
            "dependencies": [
              2
            ],
            "details": "Create or modify tsconfig.json with strict: true, esModuleInterop: true, skipLibCheck: true, and moduleResolution: 'bundler'. Configure path aliases in compilerOptions.paths: '@/*' maps to './app/*', '@components/*' to './app/components/*', '@lib/*' to './app/lib/*'. Set target to 'ES2022' and module to 'ESNext'. Include app/** and exclude node_modules, dist, .convex.\n<info added on 2025-11-09T11:21:14.459Z>\nSuccessfully configured TypeScript with strict mode and path aliases. Created tsconfig.json with comprehensive configuration including strict type safety, esModuleInterop, skipLibCheck, moduleResolution set to 'bundler' for Vite/Vinxi compatibility, target ES2022, module ESNext, and jsx react-jsx. Configured path aliases (@/* → ./app/*, @components/* → ./app/components/*, @lib/* → ./app/lib/*). Enabled additional strict settings: noUnusedLocals, noUnusedParameters, noFallthroughCasesInSwitch, forceConsistentCasingInFileNames, isolatedModules. Configured include/exclude: app/**/* included, node_modules, dist, .convex, .netlify excluded. Verified TypeScript compilation with tsc --noEmit showing no errors, tested path alias imports compile correctly, and confirmed all type checking passes.\n</info added on 2025-11-09T11:21:14.459Z>",
            "status": "done",
            "testStrategy": "Run `tsc --noEmit` to verify TypeScript configuration is valid. Test path alias imports compile correctly."
          },
          {
            "id": 4,
            "title": "Set up package.json scripts for development and build",
            "description": "Configure npm scripts for development server, production build, and preview",
            "dependencies": [
              2
            ],
            "details": "Add scripts to package.json: 'dev': 'vinxi dev' for development server, 'build': 'vinxi build' for production build, 'preview': 'vinxi preview' for preview mode, 'typecheck': 'tsc --noEmit' for type checking, 'lint': 'eslint app/' for linting. Ensure scripts reference the correct build tool (vinxi) and paths.\n<info added on 2025-11-09T11:24:31.401Z>\nPackage.json scripts configured successfully with all required scripts including dev, build, start, preview, typecheck, routes, and routes:watch. Typecheck script verified working with no errors.\n\nDiscovered blocking issue: @tanstack/start@1.120.20 has compatibility problem with @tanstack/router-generator - imports non-existent CONSTANTS export from @tanstack/start-config package. This prevents build, dev, and preview scripts from executing. Attempted downgrade of router packages to v1.131.50 but issue persists in start-config package.\n\nThis is an upstream ecosystem compatibility issue. TypeScript compilation and type checking are fully functional. Resolution options: wait for @tanstack/start update, switch to Vite + TanStack Router without Start framework, or use alternative build configuration. Scripts are syntactically correct and ready for use once compatibility issue is resolved.\n</info added on 2025-11-09T11:24:31.401Z>",
            "status": "done",
            "testStrategy": "Run `npm run dev` and verify dev server starts. Run `npm run build` and confirm dist directory is created. Run `npm run typecheck` and verify no errors."
          },
          {
            "id": 5,
            "title": "Create environment configuration files",
            "description": "Set up .env.example with placeholder keys for all required services and configure .gitignore",
            "dependencies": [
              1
            ],
            "details": "Create .env.example file with placeholders: CONVEX_URL=https://your-deployment.convex.cloud, FIRECRAWL_API_KEY=fc-your-key, SENTRY_DSN=https://your-sentry-dsn, AUTUMN_API_KEY=your-autumn-key, CLOUDFLARE_TURNSTILE_SECRET=your-turnstile-secret, CLOUDFLARE_TURNSTILE_SITE_KEY=your-site-key, GITHUB_WEBHOOK_SECRET=your-webhook-secret, NODE_ENV=development. Add comments explaining each variable's purpose. Ensure .gitignore includes .env, node_modules, dist, .convex, .netlify.\n<info added on 2025-11-09T11:27:09.755Z>\nSuccessfully created and configured environment files. Created comprehensive .env.example with all required services (NODE_ENV, CONVEX_URL, CONVEX_DEPLOY_KEY, FIRECRAWL_API_KEY, SENTRY_DSN, SENTRY_AUTH_TOKEN, AUTUMN_API_KEY, CLOUDFLARE_TURNSTILE_SECRET, CLOUDFLARE_TURNSTILE_SITE_KEY, GITHUB_WEBHOOK_SECRET, OPENAI_API_KEY) with inline comments explaining each variable's purpose. Updated .gitignore with comprehensive exclusions for .env, node_modules, dist, .vinxi, .output, .convex, .netlify, app.config.timestamp files, TypeScript build info, logs, and editor configs. Verified git correctly ignores .env file while tracking .env.example for team documentation. Environment configuration is ready for development.\n</info added on 2025-11-09T11:27:09.755Z>",
            "status": "done",
            "testStrategy": "Verify .env.example exists with all required keys. Confirm .gitignore excludes .env file. Test that .env file (if created) is not tracked by git."
          },
          {
            "id": 6,
            "title": "Initialize git repository and configure linting tools",
            "description": "Set up git repository with proper ignore rules and configure ESLint and Prettier for code quality",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Run `git init` to initialize repository. Verify .gitignore includes node_modules, .env, dist, .convex, .netlify, .DS_Store. Install eslint and prettier with `npm install -D eslint prettier @tanstack/eslint-config`. Create .eslintrc.js extending '@tanstack/eslint-config'. Create .prettierrc with singleQuote: true, semi: false, trailingComma: 'es5'. Add lint script to package.json. Make initial commit with message 'chore: initialize TanStack Start project'.",
            "status": "in-progress",
            "testStrategy": "Verify git repository is initialized with `git status`. Run `npm run lint` and confirm ESLint executes. Format a file with Prettier and verify it works. Check git status shows .env is ignored."
          }
        ]
      },
      {
        "id": 2,
        "title": "Convex backend initialization and schema definition",
        "description": "Set up Convex backend with complete data schema for workspaces, tasks, events, imports, users, memberships, contacts, comments, presence, and billing",
        "details": "Install convex@latest and initialize with `npx convex dev`. Define schema in convex/schema.ts using defineSchema and defineTable from 'convex/server'. Create tables: users (name, email, avatarUrl), workspaces (name, slug, ownerId), memberships (userId, workspaceId, role enum), imports (workspaceId, url, status enum, logs array, timestamps, raw/mapped json), events (workspaceId, title, startAt, endAt, source, url), tasks (workspaceId, title, status enum, dueAt, assigneeId, labels array, sourceId, prUrl, prStatus), contacts (workspaceId, name, email, links array), comments (taskId, authorId, body, createdAt), presence (workspaceId, userId, lastSeenAt, cursor object), billing (workspaceId, credits number, provider). Add indexes for common queries (workspace lookups, task filters, user memberships). Configure Convex deployment and sync environment.",
        "testStrategy": "Run `npx convex dev` and verify schema syncs without errors. Use Convex dashboard to inspect tables. Test basic CRUD queries in Convex console.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Convex and initialize project",
            "description": "Install convex@latest package and run npx convex dev to initialize Convex backend configuration and create initial project structure",
            "dependencies": [],
            "details": "Run `npm install convex@latest` to add Convex dependency. Execute `npx convex dev` to initialize Convex project, which creates convex/ directory, convex.json config, and sets up deployment connection. Follow prompts to authenticate and create new Convex project. Verify .env.local contains CONVEX_URL and deployment URL is set correctly. Confirm convex/ directory structure is created with _generated/ folder.",
            "status": "pending",
            "testStrategy": "Verify convex/ directory exists with convex.json and _generated/ folder. Confirm CONVEX_URL in .env.local. Run `npx convex dev` and verify connection to Convex dashboard without errors."
          },
          {
            "id": 2,
            "title": "Define users and workspaces table schemas",
            "description": "Create schema definitions for users and workspaces tables with appropriate fields, types, and relationships in convex/schema.ts",
            "dependencies": [
              1
            ],
            "details": "Create convex/schema.ts and import defineSchema, defineTable from 'convex/server' and v from 'convex/values'. Define users table with fields: name (v.string()), email (v.string()), avatarUrl (v.optional(v.string())). Define workspaces table with: name (v.string()), slug (v.string()), ownerId (v.id('users')). Use defineSchema to export schema object containing both tables. Ensure proper typing for foreign key relationship between workspaces.ownerId and users table.",
            "status": "pending",
            "testStrategy": "Run `npx convex dev` and verify schema syncs successfully. Check Convex dashboard to confirm users and workspaces tables appear with correct fields. Test querying both tables in Convex console."
          },
          {
            "id": 3,
            "title": "Define memberships and roles schema with enums",
            "description": "Create memberships table schema with userId, workspaceId foreign keys and role enumeration for access control",
            "dependencies": [
              2
            ],
            "details": "Add memberships table to convex/schema.ts with fields: userId (v.id('users')), workspaceId (v.id('workspaces')), role (v.union(v.literal('owner'), v.literal('admin'), v.literal('member'), v.literal('viewer'))). Define role enum using v.union with v.literal for each role type to ensure type safety. Consider adding createdAt (v.number()) timestamp for audit trail. Ensure foreign key relationships are properly typed for both userId and workspaceId.",
            "status": "pending",
            "testStrategy": "Verify memberships table appears in Convex dashboard with correct fields and enum values. Test inserting membership record with each role type. Confirm foreign key constraints work by attempting to insert invalid userId or workspaceId."
          },
          {
            "id": 4,
            "title": "Define imports table with complex nested fields",
            "description": "Create imports table schema with status enum, logs array, timestamps, and JSON fields for raw and mapped data storage",
            "dependencies": [
              2
            ],
            "details": "Add imports table to schema with fields: workspaceId (v.id('workspaces')), url (v.string()), status (v.union(v.literal('pending'), v.literal('processing'), v.literal('done'), v.literal('failed'))), logs (v.array(v.object({ timestamp: v.number(), level: v.string(), message: v.string() }))), createdAt (v.number()), completedAt (v.optional(v.number())), rawData (v.optional(v.any())), mappedData (v.optional(v.any())). Use v.array with nested v.object for structured logs. Use v.any() for JSON storage fields to allow flexible data structures.",
            "status": "pending",
            "testStrategy": "Verify imports table schema syncs without errors. Test inserting import record with logs array containing multiple log entries. Confirm rawData and mappedData fields accept JSON objects. Verify status enum accepts only defined literal values."
          },
          {
            "id": 5,
            "title": "Define events and tasks table schemas",
            "description": "Create comprehensive schemas for events and tasks tables with all required fields, relationships, and enums for status tracking",
            "dependencies": [
              2
            ],
            "details": "Add events table with fields: workspaceId (v.id('workspaces')), title (v.string()), startAt (v.number()), endAt (v.number()), source (v.optional(v.string())), url (v.optional(v.string())). Add tasks table with: workspaceId (v.id('workspaces')), title (v.string()), status (v.union(v.literal('todo'), v.literal('in_progress'), v.literal('done'), v.literal('archived'))), dueAt (v.optional(v.number())), assigneeId (v.optional(v.id('users'))), labels (v.array(v.string())), sourceId (v.optional(v.string())), prUrl (v.optional(v.string())), prStatus (v.optional(v.string())). Ensure proper foreign key typing for workspaceId and assigneeId.",
            "status": "pending",
            "testStrategy": "Verify both events and tasks tables appear in dashboard with correct schema. Test creating event and task records with all fields. Verify status enum validation. Confirm labels array accepts string values. Test optional fields can be omitted."
          },
          {
            "id": 6,
            "title": "Define contacts, comments, and presence table schemas",
            "description": "Create schemas for contacts, comments, and presence tables to support collaboration and real-time features",
            "dependencies": [
              2,
              5
            ],
            "details": "Add contacts table with: workspaceId (v.id('workspaces')), name (v.string()), email (v.string()), links (v.array(v.string())). Add comments table with: taskId (v.id('tasks')), authorId (v.id('users')), body (v.string()), createdAt (v.number()). Add presence table with: workspaceId (v.id('workspaces')), userId (v.id('users')), lastSeenAt (v.number()), cursor (v.optional(v.object({ x: v.number(), y: v.number(), color: v.string() }))). Ensure foreign key relationships are correctly typed across all tables.",
            "status": "pending",
            "testStrategy": "Verify all three tables sync successfully to Convex. Test inserting contact with links array. Create comment linked to task. Test presence record with cursor object. Verify foreign key constraints work correctly."
          },
          {
            "id": 7,
            "title": "Define billing table schema",
            "description": "Create billing table schema for tracking workspace credits and payment provider information",
            "dependencies": [
              2
            ],
            "details": "Add billing table to schema with fields: workspaceId (v.id('workspaces')), credits (v.number()), provider (v.optional(v.union(v.literal('stripe'), v.literal('paypal'), v.literal('manual')))). Consider adding lastUpdatedAt (v.number()) for audit trail and subscriptionId (v.optional(v.string())) for payment provider references. Ensure workspaceId foreign key is properly typed. Initialize credits with default value in mutations.",
            "status": "pending",
            "testStrategy": "Verify billing table appears in dashboard. Test creating billing record with credits value. Verify provider enum accepts defined values. Test querying billing by workspaceId. Confirm foreign key relationship to workspaces works."
          },
          {
            "id": 8,
            "title": "Add indexes for query optimization",
            "description": "Define database indexes on frequently queried fields across all tables to optimize common query patterns and improve performance",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Add indexes to schema using .index() method on table definitions. Create indexes: users by email, workspaces by slug and ownerId, memberships by userId and workspaceId (compound), imports by workspaceId and status, events by workspaceId and startAt, tasks by workspaceId, status, assigneeId, and dueAt (multiple indexes), contacts by workspaceId, comments by taskId and authorId, presence by workspaceId and userId, billing by workspaceId. Use compound indexes where queries filter on multiple fields together. Verify index naming follows Convex conventions.",
            "status": "pending",
            "testStrategy": "Run `npx convex dev` and verify all indexes are created without errors. Check Convex dashboard to confirm indexes appear on respective tables. Test queries using indexed fields and verify performance using Convex query logs. Confirm compound indexes work for multi-field queries."
          }
        ]
      },
      {
        "id": 3,
        "title": "Sentry integration for error tracking and performance monitoring",
        "description": "Integrate Sentry SDK for both client and server-side error tracking, performance monitoring, and tracing throughout the application",
        "details": "Install @sentry/node@latest and @sentry/react@latest. Create app/lib/sentry.server.ts with Sentry.init() using SENTRY_DSN, environment, release version, and tracesSampleRate: 1.0 for demo. Create app/lib/sentry.client.ts with browser-specific config including replaysSessionSampleRate and replaysOnErrorSampleRate. Wrap TanStack Start root component with Sentry.ErrorBoundary. Add performance instrumentation to critical flows: import streaming, task mutations, webhook processing. Create custom Sentry tags for workspaceId, importId, and feature areas. Set up source maps upload in build script. Configure beforeSend hook to sanitize sensitive data (tokens, emails). Add Sentry.captureException() calls in error boundaries and critical try/catch blocks.",
        "testStrategy": "Trigger a test error and verify it appears in Sentry dashboard with correct context. Test performance trace for import flow. Verify source maps resolve correctly. Force an error during import to validate capture.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Sentry SDKs and configure package dependencies",
            "description": "Install @sentry/node and @sentry/react packages for server and client-side error tracking",
            "dependencies": [],
            "details": "Run npm install @sentry/node@latest @sentry/react@latest. Verify package.json includes both dependencies with latest versions. Ensure peer dependencies are satisfied for TanStack Start compatibility.",
            "status": "pending",
            "testStrategy": "Verify packages appear in package.json and node_modules. Run npm ls @sentry/node @sentry/react to confirm installation."
          },
          {
            "id": 2,
            "title": "Create server-side Sentry configuration",
            "description": "Set up server-side Sentry initialization with DSN, environment, release version, and performance tracing",
            "dependencies": [
              1
            ],
            "details": "Create app/lib/sentry.server.ts with Sentry.init() configuration. Use SENTRY_DSN environment variable for DSN. Set environment from NODE_ENV or custom env var. Configure release version from package.json or git SHA. Set tracesSampleRate to 1.0 for comprehensive demo monitoring. Add integrations for Node.js HTTP, Express, and any framework-specific handlers.",
            "status": "pending",
            "testStrategy": "Trigger a test server error using Sentry.captureException() and verify it appears in Sentry dashboard with correct environment, release, and tags."
          },
          {
            "id": 3,
            "title": "Create client-side Sentry configuration with replays",
            "description": "Set up browser-specific Sentry configuration including session replays and error replays",
            "dependencies": [
              1
            ],
            "details": "Create app/lib/sentry.client.ts with browser-specific Sentry.init() config. Use same SENTRY_DSN as server. Configure replaysSessionSampleRate (e.g., 0.1 for 10% of sessions) and replaysOnErrorSampleRate (1.0 to capture all error sessions). Add BrowserTracing integration for performance monitoring. Set tracesSampleRate to 1.0 for demo. Include beforeBreadcrumb to filter sensitive data from breadcrumbs.",
            "status": "pending",
            "testStrategy": "Trigger a client-side error and verify it appears in Sentry with session replay attached. Verify performance traces show page load and navigation timing."
          },
          {
            "id": 4,
            "title": "Integrate Sentry ErrorBoundary in TanStack Start root component",
            "description": "Wrap application root with Sentry.ErrorBoundary to catch and report React component errors",
            "dependencies": [
              3
            ],
            "details": "Import Sentry from app/lib/sentry.client.ts in root component. Wrap main app component with <Sentry.ErrorBoundary fallback={ErrorFallbackComponent} showDialog>. Create ErrorFallbackComponent to display user-friendly error message with option to send feedback. Ensure ErrorBoundary includes beforeCapture callback to add custom context. Test that errors in child components are caught and reported.",
            "status": "pending",
            "testStrategy": "Throw a test error in a child component and verify ErrorBoundary catches it, displays fallback UI, and sends error to Sentry with React component stack trace."
          },
          {
            "id": 5,
            "title": "Add performance instrumentation to critical application flows",
            "description": "Instrument import streaming, task mutations, and webhook processing with Sentry performance traces",
            "dependencies": [
              2,
              3
            ],
            "details": "Add Sentry.startTransaction() calls at the beginning of critical flows: (1) Import streaming endpoint - create transaction 'import.stream' with importId tag, (2) Task mutation handlers - wrap with 'task.mutation' transaction including taskId, (3) Webhook processing - create 'webhook.process' transaction with webhook type. Add child spans using transaction.startChild() for sub-operations like API calls, database queries, and parsing logic. Call transaction.finish() when complete. Use Sentry.setContext() to add operation-specific metadata.",
            "status": "pending",
            "testStrategy": "Execute an import flow and verify Sentry performance dashboard shows full transaction trace with child spans for Firecrawl call, parsing, and Convex mutations. Confirm transaction includes custom tags."
          },
          {
            "id": 6,
            "title": "Configure custom Sentry tags and beforeSend sanitization hook",
            "description": "Set up custom tags for workspace and import context, and implement data sanitization to remove sensitive information",
            "dependencies": [
              2,
              3
            ],
            "details": "In both sentry.server.ts and sentry.client.ts, configure beforeSend hook to sanitize sensitive data: strip tokens from headers/body, redact email addresses with regex, remove API keys from URLs. Add Sentry.setTag() calls in application code to attach workspaceId, importId, and feature area tags to all events. Create helper function setSentryContext(workspaceId, importId, feature) to standardize tagging. Ensure tags are set before any Sentry.captureException() or transaction calls.",
            "status": "pending",
            "testStrategy": "Trigger error with sensitive data (token, email) in context and verify Sentry event shows sanitized values. Confirm custom tags (workspaceId, importId, feature) appear on events and can be filtered in Sentry dashboard."
          },
          {
            "id": 7,
            "title": "Configure source maps upload in build script",
            "description": "Set up build process to generate and upload source maps to Sentry for accurate error stack traces",
            "dependencies": [
              1
            ],
            "details": "Install @sentry/cli or @sentry/webpack-plugin for source map upload. Add build script configuration to generate source maps (ensure sourceMap: true in build config). Create sentry.properties or .sentryclirc with org and project. Add post-build script to upload source maps using sentry-cli releases files <release> upload-sourcemaps ./dist --url-prefix '~/' or webpack plugin config. Set SENTRY_AUTH_TOKEN environment variable for CI/CD. Ensure release version matches Sentry.init() release parameter.",
            "status": "pending",
            "testStrategy": "Trigger production error and verify stack trace in Sentry resolves to original TypeScript/JSX source code with correct line numbers, not minified bundle code."
          }
        ]
      },
      {
        "id": 4,
        "title": "Netlify deployment configuration and environment setup",
        "description": "Configure Netlify hosting with build settings, environment variables, deploy previews, and proper redirects for TanStack Start application",
        "details": "Create netlify.toml with build command 'npm run build', publish directory 'dist/public', and functions directory 'dist/server'. Configure redirects for SPA routing: '/* /index.html 200'. Set up environment variables in Netlify dashboard: CONVEX_URL, CONVEX_DEPLOY_KEY, FIRECRAWL_API_KEY, SENTRY_DSN, SENTRY_AUTH_TOKEN, AUTUMN_API_KEY, CLOUDFLARE_TURNSTILE_SECRET, CLOUDFLARE_TURNSTILE_SITE_KEY, GITHUB_WEBHOOK_SECRET, NODE_VERSION=20. Enable deploy previews for all pull requests. Configure build hooks for Convex deployment triggers. Set up custom domain if available. Add _headers file for security headers (CSP, X-Frame-Options, etc.). Configure serverless functions timeout to 26 seconds for import operations.",
        "testStrategy": "Deploy to Netlify and verify build succeeds. Test environment variables are accessible. Verify deploy preview creation on PR. Test custom domain SSL. Confirm server functions execute successfully.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create netlify.toml configuration file",
            "description": "Create netlify.toml in project root with build command, publish directory, functions directory, and Node.js version specification for TanStack Start deployment",
            "dependencies": [],
            "details": "Create netlify.toml file with the following configuration: [build] command = 'npm run build', publish = 'dist/public', functions = 'dist/server'. Add [build.environment] section with NODE_VERSION = '20'. This file defines how Netlify builds and deploys the TanStack Start application, specifying the build output directories for both static assets (dist/public) and serverless functions (dist/server).",
            "status": "pending",
            "testStrategy": "Verify netlify.toml exists and contains correct build settings. Deploy to Netlify and confirm build command executes successfully. Check build logs show Node 20 is used."
          },
          {
            "id": 2,
            "title": "Configure SPA redirects and routing rules",
            "description": "Set up redirect rules in netlify.toml to handle client-side routing for the single-page application, ensuring all routes properly resolve",
            "dependencies": [
              1
            ],
            "details": "Add [[redirects]] section to netlify.toml with: from = '/*', to = '/index.html', status = 200. This ensures that all routes are handled by the SPA router rather than returning 404s. The 200 status (rewrite) is crucial for preserving the URL while serving index.html, allowing TanStack Router to handle the routing client-side.",
            "status": "pending",
            "testStrategy": "Deploy and navigate to non-root routes directly (e.g., /settings, /import). Verify routes load correctly without 404 errors. Test browser refresh on nested routes."
          },
          {
            "id": 3,
            "title": "Set up environment variables in Netlify dashboard",
            "description": "Configure all required environment variables in Netlify dashboard for production deployment including Convex, Firecrawl, Sentry, Autumn, Cloudflare Turnstile, and GitHub webhook secrets",
            "dependencies": [],
            "details": "Access Netlify dashboard Site Settings > Environment Variables. Add the following variables: CONVEX_URL (from Convex dashboard), CONVEX_DEPLOY_KEY (for deployment), FIRECRAWL_API_KEY (web scraping), SENTRY_DSN and SENTRY_AUTH_TOKEN (error tracking), AUTUMN_API_KEY (AI service), CLOUDFLARE_TURNSTILE_SECRET and CLOUDFLARE_TURNSTILE_SITE_KEY (bot protection), GITHUB_WEBHOOK_SECRET (webhook validation), NODE_VERSION=20. Ensure all values are copied correctly from respective service dashboards.",
            "status": "pending",
            "testStrategy": "Deploy application and verify all environment variables are accessible in server code. Test each integration (Convex, Firecrawl, Sentry) to confirm API calls succeed with configured credentials."
          },
          {
            "id": 4,
            "title": "Create _headers file for security headers configuration",
            "description": "Add _headers file to configure security headers including Content Security Policy, X-Frame-Options, and other security-related HTTP headers",
            "dependencies": [],
            "details": "Create public/_headers file (will be copied to dist/public during build) with security headers for all routes: /*\\n  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' challenges.cloudflare.com; connect-src 'self' *.convex.cloud *.sentry.io; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'\\n  X-Frame-Options: DENY\\n  X-Content-Type-Options: nosniff\\n  Referrer-Policy: strict-origin-when-cross-origin\\n  Permissions-Policy: geolocation=(), microphone=(), camera=(). Adjust CSP directives to allow necessary third-party services while maintaining security.",
            "status": "pending",
            "testStrategy": "Deploy and inspect response headers using browser DevTools Network tab. Verify CSP header is present and correctly formatted. Test that all external resources (Convex, Sentry, Turnstile) load successfully. Confirm no CSP violations in console."
          },
          {
            "id": 5,
            "title": "Configure deploy previews for pull requests",
            "description": "Enable and configure Netlify deploy previews to automatically create preview deployments for all pull requests",
            "dependencies": [],
            "details": "In Netlify dashboard, navigate to Site Settings > Build & Deploy > Deploy Contexts. Enable 'Deploy Previews' for all pull requests. Configure branch deploy settings to deploy all branches or specify pattern. Set up preview-specific environment variables if needed (use same production values for demo). Deploy previews will allow testing changes in isolated environments before merging to main branch.",
            "status": "pending",
            "testStrategy": "Create a test pull request with a minor change. Verify Netlify automatically creates a deploy preview. Confirm preview URL is accessible and functions correctly. Test environment variables are available in preview deployment."
          },
          {
            "id": 6,
            "title": "Configure serverless functions timeout settings",
            "description": "Set serverless functions timeout to 26 seconds in netlify.toml to accommodate long-running import operations",
            "dependencies": [
              1
            ],
            "details": "Add [functions] section to netlify.toml with: [functions]\\n  node_bundler = 'esbuild'\\n  [functions.timeouts]\\n    default = 26. This increases the default 10-second timeout to 26 seconds (Netlify's maximum for free tier) to handle the import streaming operation which may take longer due to Firecrawl scraping, AI processing, and database insertions. Note: 26 seconds is the maximum on free tier; Pro tier allows up to 26 seconds background functions.",
            "status": "pending",
            "testStrategy": "Deploy and trigger import operation with a complex URL. Monitor function execution time in Netlify function logs. Verify import completes without timeout errors. Test with URLs that take 15-25 seconds to process."
          }
        ]
      },
      {
        "id": 5,
        "title": "Authentication system with user management",
        "description": "Implement user authentication using Convex Auth or a lightweight JWT-based system with session management",
        "details": "Install @convex-dev/auth@latest for simplified authentication. Configure OAuth providers (GitHub, Google) in convex/auth.config.ts. Create convex/users.ts with queries for getUser, getCurrentUser, and mutations for updateProfile. Implement session management using HTTP-only cookies. Create app/lib/auth.ts with useAuth() hook returning user, isLoading, login, logout. Add protected route wrapper withAuth() for server functions. Create login/signup UI components with social OAuth buttons. Store user profile (name, email, avatarUrl) in Convex users table. Implement user session persistence across page reloads. Add user avatar display in navbar with dropdown menu.",
        "testStrategy": "Test OAuth flow end-to-end with GitHub provider. Verify session persistence after page reload. Test logout clears session. Verify protected routes redirect unauthenticated users. Test user profile updates reflect immediately.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure Convex Auth package",
            "description": "Install @convex-dev/auth@latest and set up the base authentication configuration in the Convex backend",
            "dependencies": [],
            "details": "Run npm install @convex-dev/auth@latest. Create convex/auth.config.ts file with base configuration. Import and initialize Convex Auth in convex/_generated/api.ts or appropriate entry point. Set up environment variables for OAuth client secrets (GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET). Configure auth providers array in auth.config.ts with GitHub and Google providers. Add auth middleware to Convex HTTP routes if required by the library.",
            "status": "pending",
            "testStrategy": "Verify auth.config.ts exports valid configuration. Test that environment variables are loaded correctly. Confirm Convex Auth initializes without errors in development server logs."
          },
          {
            "id": 2,
            "title": "Configure OAuth providers for GitHub and Google",
            "description": "Set up OAuth provider configurations in convex/auth.config.ts with callback URLs and scopes",
            "dependencies": [
              1
            ],
            "details": "In convex/auth.config.ts, configure GitHub OAuth provider with client ID, client secret, and callback URL (e.g., /api/auth/callback/github). Add scopes: ['read:user', 'user:email']. Configure Google OAuth provider similarly with callback URL /api/auth/callback/google and scopes ['profile', 'email']. Register OAuth apps in GitHub Developer Settings and Google Cloud Console. Set redirect URIs to match Convex deployment URLs (both local and production). Store client secrets in Convex environment variables dashboard.",
            "status": "pending",
            "testStrategy": "Test OAuth flow by clicking GitHub login and verifying redirect to GitHub authorization page. Confirm callback URL receives authorization code. Test Google OAuth similarly. Verify error handling for invalid credentials."
          },
          {
            "id": 3,
            "title": "Implement session management with HTTP-only cookies",
            "description": "Create secure session management using HTTP-only cookies to store authentication tokens",
            "dependencies": [
              1
            ],
            "details": "Configure Convex Auth to use HTTP-only cookies for session storage. Set cookie options: httpOnly: true, secure: true (production), sameSite: 'lax', maxAge: 30 days. Implement session creation after successful OAuth callback. Create session token using Convex Auth's built-in token generation. Store session ID in cookie and map to user ID in Convex sessions table. Implement session validation middleware that checks cookie on each request. Add session refresh logic to extend expiration on activity. Implement secure session revocation on logout.",
            "status": "pending",
            "testStrategy": "Verify session cookie is set after login with httpOnly and secure flags. Test session persists across browser refresh. Confirm session validates correctly on protected routes. Test logout clears session cookie and invalidates server-side session."
          },
          {
            "id": 4,
            "title": "Create user queries and mutations in Convex",
            "description": "Implement convex/users.ts with queries for fetching user data and mutations for profile updates",
            "dependencies": [
              1
            ],
            "details": "Create convex/users.ts file. Define users table schema with fields: id, email, name, avatarUrl, githubId, googleId, createdAt, updatedAt. Implement query getUser(userId) returning user object or null. Implement query getCurrentUser() that gets current session user ID and returns full user profile. Create mutation updateProfile({ name, avatarUrl }) that updates authenticated user's profile fields. Add mutation createUserFromOAuth({ email, name, avatarUrl, provider, providerId }) called during OAuth callback. Implement query listUsers() for admin purposes. Add indexes on email and provider IDs for efficient lookups.",
            "status": "pending",
            "testStrategy": "Test getUser returns correct user object for valid ID. Verify getCurrentUser returns null when unauthenticated. Test updateProfile successfully modifies user fields. Confirm createUserFromOAuth creates new user record. Verify queries use indexes efficiently."
          },
          {
            "id": 5,
            "title": "Build protected route middleware with withAuth wrapper",
            "description": "Create app/lib/auth.ts with protected route wrapper to guard server functions and API routes",
            "dependencies": [
              3,
              4
            ],
            "details": "Create app/lib/auth.ts file. Implement withAuth() higher-order function that wraps server functions and API routes. In wrapper, validate session cookie and retrieve current user using getCurrentUser() query. If no valid session, return 401 Unauthorized or redirect to /login. If authenticated, inject user object into request context and call wrapped function. Create getServerUser() helper that extracts user from request context. Add optional role-based authorization parameter to withAuth({ roles: ['admin'] }). Implement useRequireAuth() hook for client-side route protection that redirects to login page.",
            "status": "pending",
            "testStrategy": "Test withAuth wrapper blocks unauthenticated requests to protected routes. Verify authenticated requests pass through with user context. Test role-based authorization blocks unauthorized users. Confirm redirect to /login works for protected pages without auth."
          },
          {
            "id": 6,
            "title": "Design and build login/signup UI components",
            "description": "Create responsive login and signup pages with social OAuth buttons and form validation",
            "dependencies": [
              2
            ],
            "details": "Create app/routes/login.tsx and app/routes/signup.tsx pages. Build LoginForm component with GitHub and Google OAuth buttons using provider-specific branding. Add 'Continue with GitHub' and 'Continue with Google' buttons that trigger OAuth flow via Convex Auth endpoints. Style buttons with provider colors and logos. Create SignupForm component with same OAuth options. Add loading states during OAuth redirect. Implement error message display for failed authentication. Add redirect parameter to return users to intended page after login (e.g., /login?redirect=/dashboard). Style forms with shadcn/ui components for consistency. Add responsive layout for mobile devices.",
            "status": "pending",
            "testStrategy": "Test OAuth buttons trigger correct provider authorization flow. Verify loading states display during authentication. Test error messages appear for invalid credentials. Confirm redirect parameter works after successful login. Test responsive design on mobile viewport."
          },
          {
            "id": 7,
            "title": "Implement useAuth hook for client-side auth state",
            "description": "Create app/lib/auth.ts useAuth() hook returning user, isLoading, login, and logout functions",
            "dependencies": [
              3,
              4
            ],
            "details": "In app/lib/auth.ts, implement useAuth() React hook. Use Convex useQuery(api.users.getCurrentUser) to fetch current user. Return object with properties: { user, isLoading, isAuthenticated, login(provider), logout() }. Implement login(provider) function that redirects to OAuth endpoint for specified provider (github/google). Implement logout() function that calls Convex mutation to invalidate session and clear cookie, then redirects to homepage. Add loading state that returns true while user query is pending. Export useUser() convenience hook that returns just the user object. Add useRequireAuth() hook that redirects to /login if not authenticated.",
            "status": "pending",
            "testStrategy": "Test useAuth hook returns correct user object when authenticated. Verify isLoading is true during initial load. Test login() triggers OAuth flow. Confirm logout() clears session and redirects. Test useRequireAuth redirects unauthenticated users to login."
          },
          {
            "id": 8,
            "title": "Implement session persistence across page reloads",
            "description": "Ensure user sessions persist correctly across browser refreshes and new tabs using cookie-based sessions",
            "dependencies": [
              3,
              7
            ],
            "details": "Configure session cookie maxAge to 30 days for persistent sessions. Implement session rehydration in app root layout or _app.tsx by calling getCurrentUser() query on mount. Add session validation that checks cookie on each page load and verifies against Convex sessions table. Implement session refresh mechanism that extends expiration on user activity. Add client-side session storage in localStorage as backup for offline detection (store user ID only, not sensitive data). Implement automatic session cleanup job in Convex to delete expired sessions after 30 days of inactivity. Handle session errors gracefully by clearing invalid sessions and prompting re-login.",
            "status": "pending",
            "testStrategy": "Test session persists after browser refresh. Verify user remains logged in after closing and reopening browser within 30 days. Test session invalidates correctly after logout. Confirm expired sessions are cleaned up automatically. Test session refresh extends expiration on activity."
          },
          {
            "id": 9,
            "title": "Create user avatar display and dropdown menu in navbar",
            "description": "Build navbar component with user avatar image and dropdown menu containing profile and logout options",
            "dependencies": [
              4,
              7
            ],
            "details": "Create app/components/UserMenu.tsx component. Use useAuth() hook to get current user. Display user.avatarUrl in circular avatar image (40x40px) in navbar top-right. Use shadcn/ui DropdownMenu component for menu. On avatar click, show dropdown with user name, email, and menu items: 'Profile', 'Settings', 'Logout'. Style with Tailwind CSS for consistent design. Add loading skeleton while user data loads. Implement logout onClick that calls useAuth().logout(). Add link to /profile page from Profile menu item. Display user initials as fallback if avatarUrl is null. Add online status indicator (green dot) if user is active. Handle unauthenticated state by showing 'Sign In' button instead of avatar.",
            "status": "pending",
            "testStrategy": "Test avatar displays user image correctly. Verify dropdown menu opens on click and contains all menu items. Test logout button calls logout function and clears session. Confirm fallback initials display when no avatar. Test responsive design on mobile with hamburger menu."
          }
        ]
      },
      {
        "id": "6",
        "title": "Core navigation and layout structure",
        "description": "Build the main application shell with navigation, routing, and responsive layout using TanStack Router",
        "status": "pending",
        "dependencies": [
          1,
          5
        ],
        "priority": "high",
        "details": "Install @tanstack/react-router@latest. Create route tree in app/routes/ with __root.tsx (layout), index.tsx (dashboard), import.tsx, tasks.tsx, tasks/$taskId.tsx, calendar.tsx, dev.tsx, settings.tsx, share/$slug.tsx, sponsors.tsx. Implement RootRoute with ErrorBoundary and pending component. Create app/components/Layout.tsx with sidebar navigation (links to Dashboard, Import, Tasks, Calendar, Dev, Settings), workspace switcher, and user menu. Use Tailwind CSS for styling with mobile-first responsive design. Add active link highlighting using router's useMatch(). Implement collapsible sidebar for mobile. Add loading states using router's useNavigation(). Create breadcrumb navigation for deep routes. Set up route preloading on hover for instant navigation. NOTE: Placeholder route files and basic Layout component have been created with responsive sidebar, mobile menu, active link highlighting, error boundaries, and 404 handler. TypeScript compilation verified. Full implementation and Convex integration pending.",
        "testStrategy": "Navigate between all routes and verify correct component rendering. Test responsive layout on mobile and desktop viewports. Verify active link highlighting. Test breadcrumb navigation. Confirm loading states appear during navigation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure TanStack Router",
            "description": "Install @tanstack/react-router@latest and set up initial router configuration with TypeScript support",
            "dependencies": [],
            "details": "Run npm install @tanstack/react-router@latest. Create app/routes directory structure. Set up router configuration in app/router.tsx with createRouter and RouterProvider. Configure TypeScript types for router context and route definitions. Verify installation by running dev server.",
            "status": "done",
            "testStrategy": "Verify package is installed in package.json. Confirm TypeScript compilation with no router-related errors. Test dev server starts successfully."
          },
          {
            "id": 2,
            "title": "Create route tree structure with all route files",
            "description": "Set up complete route tree in app/routes/ including root, dashboard, tasks, calendar, settings, and all other routes",
            "dependencies": [
              1
            ],
            "details": "Create app/routes/__root.tsx as the root layout route. Add index.tsx for dashboard, import.tsx for import page, tasks.tsx for task list, tasks/$taskId.tsx for task detail (dynamic route), calendar.tsx, dev.tsx for development tools, settings.tsx, share/$slug.tsx for shared views (dynamic route), and sponsors.tsx. Each file should export a Route using createRoute or createFileRoute. Include basic placeholder components for each route.",
            "status": "done",
            "testStrategy": "Navigate to each route path and verify correct component renders. Test dynamic routes with sample IDs. Confirm route tree structure in router devtools."
          },
          {
            "id": 3,
            "title": "Implement root layout with ErrorBoundary and pending states",
            "description": "Configure __root.tsx with error handling, loading states, and outlet for child routes",
            "dependencies": [
              2
            ],
            "details": "In app/routes/__root.tsx, implement RootRoute with ErrorBoundary component to catch and display routing errors gracefully. Add pending component to show loading UI during route transitions. Include Outlet component for rendering child routes. Set up global error logging integration. Add NotFound component for 404 handling. Configure route context types.",
            "status": "done",
            "testStrategy": "Trigger navigation errors and verify ErrorBoundary displays error UI. Test pending states during slow route loads. Navigate to non-existent route and confirm 404 handling."
          },
          {
            "id": 4,
            "title": "Build sidebar navigation component with Layout shell",
            "description": "Create app/components/Layout.tsx with sidebar containing navigation links to all main routes",
            "dependencies": [
              3
            ],
            "details": "Create Layout.tsx component with sidebar navigation containing links to Dashboard, Import, Tasks, Calendar, Dev, and Settings. Use Link components from TanStack Router. Add user menu component in sidebar header. Implement workspace switcher UI component. Style with Tailwind CSS using mobile-first approach. Create semantic HTML structure with nav, aside, and main elements. Add aria labels for accessibility.",
            "status": "done",
            "testStrategy": "Render Layout component and verify all navigation links are present. Click each link and confirm navigation occurs. Verify sidebar structure is semantic and accessible."
          },
          {
            "id": 5,
            "title": "Implement workspace switcher UI component",
            "description": "Build workspace switcher dropdown/modal allowing users to switch between workspaces from the sidebar",
            "dependencies": [
              4
            ],
            "details": "Create WorkspaceSwitcher component in app/components/WorkspaceSwitcher.tsx. Fetch current user's workspaces using Convex query. Display workspace list in dropdown menu with current workspace highlighted. Add search/filter for workspaces if user has many. Include 'Create workspace' action. Handle workspace switching by updating router context and redirecting. Style with Tailwind CSS matching sidebar design. Add keyboard navigation support.",
            "status": "pending",
            "testStrategy": "Open workspace switcher and verify workspace list displays. Switch workspaces and confirm app context updates. Test search/filter functionality. Verify keyboard navigation works."
          },
          {
            "id": 6,
            "title": "Implement responsive layout with collapsible mobile sidebar",
            "description": "Add mobile-responsive behavior to Layout with collapsible sidebar for small screens",
            "dependencies": [
              4
            ],
            "details": "Add responsive CSS classes using Tailwind breakpoints (sm:, md:, lg:). Implement sidebar state management with useState for open/closed. Add hamburger menu button visible only on mobile. Sidebar should be hidden by default on mobile and slide in when opened. Add overlay backdrop when sidebar is open on mobile. Ensure main content area adjusts when sidebar toggles. Use CSS transitions for smooth animations. Test on multiple viewport sizes.",
            "status": "done",
            "testStrategy": "Test layout on mobile viewport (< 768px) and verify sidebar is hidden by default. Click hamburger menu and confirm sidebar slides in. Test on tablet and desktop viewports and verify sidebar is always visible. Verify backdrop click closes mobile sidebar."
          },
          {
            "id": 7,
            "title": "Add active link highlighting and breadcrumb navigation",
            "description": "Implement visual indicators for active navigation links and breadcrumb trail for nested routes",
            "dependencies": [
              4,
              2
            ],
            "details": "Use useMatch() or useMatchRoute() hook from TanStack Router to detect active routes. Apply active styles (bg color, border, font weight) to current navigation link using Tailwind CSS. Create Breadcrumb component in app/components/Breadcrumb.tsx that reads current route path and generates breadcrumb trail. Display breadcrumbs in main content header for nested routes like tasks/$taskId. Style breadcrumbs with separators and links to parent routes.",
            "status": "done",
            "testStrategy": "Navigate between routes and verify current route link is highlighted in sidebar. Navigate to nested route like /tasks/123 and verify breadcrumb shows 'Tasks > Task 123'. Click breadcrumb segments and confirm navigation to parent routes."
          },
          {
            "id": 8,
            "title": "Implement route preloading and loading states",
            "description": "Set up route preloading on link hover and display loading indicators during navigation transitions",
            "dependencies": [
              3,
              7
            ],
            "details": "Configure router with preload: 'intent' option to enable hover preloading. Add onMouseEnter handlers to navigation links to trigger router.preloadRoute(). Use useNavigation() hook to detect pending navigations and show loading indicators. Create LoadingBar component that displays at top of layout during transitions. Add spinner or skeleton UI in pending component for route-level loading. Ensure preloaded routes cache properly. Test with network throttling to verify loading states.",
            "status": "pending",
            "testStrategy": "Hover over navigation links and verify route preloading occurs (check network tab). Navigate between routes and confirm loading bar appears during transitions. Test with slow network and verify loading states display appropriately. Verify preloaded routes navigate instantly on click."
          },
          {
            "id": 9,
            "title": "Integrate workspace switcher with Convex queries",
            "description": "Connect workspace switcher component to Convex backend to fetch and manage user workspaces dynamically",
            "dependencies": [
              5
            ],
            "details": "Implement Convex query in convex/workspaces.ts to list workspaces for current user. Update WorkspaceSwitcher component to use Convex useQuery hook for reactive workspace data. Handle workspace selection by updating app context and triggering navigation. Implement create workspace mutation that adds new workspace to Convex database. Add loading states for workspace query. Handle empty state when user has no workspaces. Ensure workspace switching updates all dependent queries reactively.",
            "status": "pending",
            "testStrategy": "Open workspace switcher and verify workspaces load from Convex. Create new workspace and confirm it appears in list immediately. Switch workspaces and verify app context updates across all routes. Test with multiple browser tabs and confirm workspace changes sync in real-time."
          },
          {
            "id": 10,
            "title": "Enhance Layout with user menu and profile integration",
            "description": "Build user menu component in Layout with profile display, settings link, and logout functionality",
            "dependencies": [
              4
            ],
            "details": "Create UserMenu component in app/components/UserMenu.tsx. Display user avatar and name from Convex auth context. Add dropdown menu with options: Profile, Settings, Logout. Implement logout handler using Convex auth mutation. Add link to settings route. Style with Tailwind CSS matching sidebar design. Add hover and focus states for accessibility. Handle loading state while user data fetches.",
            "status": "pending",
            "testStrategy": "Open user menu and verify user profile displays correctly. Click Settings and confirm navigation to settings route. Click Logout and verify user session ends and redirects to login. Test keyboard navigation through menu items."
          }
        ]
      },
      {
        "id": 7,
        "title": "Cloudflare Turnstile integration for import form protection",
        "description": "Integrate Cloudflare Turnstile widget on import form with server-side validation to prevent abuse",
        "details": "Add Turnstile script to app HTML head: <script src='https://challenges.cloudflare.com/turnstile/v0/api.js' async defer></script>. Create app/components/TurnstileWidget.tsx wrapping the cf-turnstile div with sitekey from env. Implement useCallback to handle turnstile callback and store token in component state. Add Turnstile widget to import form before submit button. Create server function validateTurnstile(token: string, remoteIP: string) that POSTs to https://challenges.cloudflare.com/turnstile/v0/siteverify with secret key. Return boolean success. In import.start server function, extract client IP from request headers (CF-Connecting-IP or X-Forwarded-For) and call validateTurnstile before proceeding. Return 403 error if validation fails. Log validation failures to Sentry with IP and timestamp.",
        "testStrategy": "Test import form rejects submission without Turnstile token. Verify Turnstile widget renders and callback fires. Test server-side validation with valid and invalid tokens. Confirm failed validation blocks import and logs to Sentry. Test with multiple rapid requests to verify rate limiting.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Cloudflare Turnstile script to application HTML head",
            "description": "Integrate the Turnstile challenge script into the root HTML document to enable widget functionality across the application",
            "dependencies": [],
            "details": "Locate the root HTML template file (likely app/root.tsx or equivalent entry point). Add the Turnstile script tag to the <head> section: <script src='https://challenges.cloudflare.com/turnstile/v0/api.js' async defer></script>. Ensure the script loads asynchronously to avoid blocking page rendering. Verify the script is present in the rendered HTML by inspecting the page source.",
            "status": "pending",
            "testStrategy": "Inspect the rendered HTML head to confirm the Turnstile script tag is present. Verify the script loads successfully in browser dev tools network tab without errors."
          },
          {
            "id": 2,
            "title": "Create TurnstileWidget React component with callback handling",
            "description": "Build a reusable React component that wraps the Cloudflare Turnstile widget with proper state management and callback handling",
            "dependencies": [
              1
            ],
            "details": "Create app/components/TurnstileWidget.tsx. Component should accept onVerify callback prop. Render a div with className='cf-turnstile' and data-sitekey attribute from environment variable TURNSTILE_SITEKEY. Use useCallback to define verification callback that receives token from Turnstile and stores it in component state using useState. Implement useEffect to initialize widget after mount. Export component with TypeScript interface for props including onVerify: (token: string) => void.",
            "status": "pending",
            "testStrategy": "Render component in isolation and verify the cf-turnstile div appears with correct sitekey. Test that callback fires when challenge is completed and token is passed to parent component. Verify widget resets correctly on multiple attempts."
          },
          {
            "id": 3,
            "title": "Integrate Turnstile widget into import form with token state",
            "description": "Add the TurnstileWidget component to the import form and manage the verification token state for submission",
            "dependencies": [
              2
            ],
            "details": "Open app/routes/import.tsx (or equivalent import form route). Import TurnstileWidget component. Add useState for storing turnstile token. Insert <TurnstileWidget onVerify={(token) => setTurnstileToken(token)} /> before the submit button in the form. Update form submission handler to include turnstile token in the request payload. Disable submit button until turnstile token is present. Add visual feedback to indicate verification is required.",
            "status": "pending",
            "testStrategy": "Test that form submit button is disabled until Turnstile challenge is completed. Verify token is included in form submission payload. Test that form rejects submission if token is missing or invalid."
          },
          {
            "id": 4,
            "title": "Implement server-side Turnstile validation function",
            "description": "Create a server utility function to validate Turnstile tokens by calling Cloudflare's siteverify API endpoint",
            "dependencies": [],
            "details": "Create app/lib/turnstile.server.ts. Implement async function validateTurnstile(token: string, remoteIP: string): Promise<boolean>. Function should POST to https://challenges.cloudflare.com/turnstile/v0/siteverify with body containing { secret: process.env.TURNSTILE_SECRET_KEY, response: token, remoteip: remoteIP }. Parse JSON response and return response.success boolean. Add error handling for network failures with try-catch. Include timeout of 5 seconds for the request. Type the response interface for better type safety.",
            "status": "pending",
            "testStrategy": "Unit test with valid and invalid tokens to verify correct boolean return. Test with network timeout to ensure graceful failure. Mock Cloudflare API and verify correct request payload structure. Test returns false on API errors."
          },
          {
            "id": 5,
            "title": "Add Turnstile validation to import.start server function with IP extraction",
            "description": "Integrate Turnstile validation into the import server endpoint with proper IP address extraction from request headers",
            "dependencies": [
              3,
              4
            ],
            "details": "Locate the import.start server function (likely in app/routes/api/import or similar). Import validateTurnstile from app/lib/turnstile.server.ts. Extract client IP from request headers: first check CF-Connecting-IP (Cloudflare), then X-Forwarded-For, then X-Real-IP, fallback to request.socket.remoteAddress. For X-Forwarded-For, split by comma and take first IP. Extract turnstile token from request body. Call await validateTurnstile(token, clientIP) before proceeding with import logic. If validation returns false, return Response with status 403 and JSON body { error: 'Turnstile validation failed' }. If token is missing, return 400 with appropriate error message.",
            "status": "pending",
            "testStrategy": "Test import endpoint rejects requests without Turnstile token (400 error). Test with invalid token returns 403. Test with valid token proceeds to import logic. Verify correct IP extraction from different header configurations. Test with mock Cloudflare headers."
          },
          {
            "id": 6,
            "title": "Implement error logging and monitoring for Turnstile validation failures",
            "description": "Add comprehensive error logging to Sentry for all Turnstile validation failures with relevant context for monitoring and debugging",
            "dependencies": [
              5
            ],
            "details": "In the import.start server function, when validateTurnstile returns false or throws an error, capture the event to Sentry using Sentry.captureMessage or Sentry.captureException. Include context: client IP address, timestamp (new Date().toISOString()), request URL, user agent from headers. Set severity level to 'warning' for validation failures and 'error' for API errors. Add tags: { validation_type: 'turnstile', failure_reason: 'invalid_token' | 'api_error' | 'missing_token' }. Create a custom breadcrumb before validation attempt. Ensure sensitive data (tokens, secrets) is not logged.",
            "status": "pending",
            "testStrategy": "Trigger validation failure and verify event appears in Sentry dashboard with correct severity and tags. Confirm IP address and timestamp are included in context. Test API error scenario logs with 'error' severity. Verify no sensitive data (tokens, secret keys) appears in Sentry logs."
          }
        ]
      },
      {
        "id": 8,
        "title": "Workspace creation and management",
        "description": "Implement workspace CRUD operations with slug generation, ownership tracking, and membership management",
        "details": "Create convex/workspaces.ts with mutations: createWorkspace(name), updateWorkspace(id, name), deleteWorkspace(id). Generate URL-safe slugs using nanoid@5 or slugify library. Create convex/memberships.ts with queries: getWorkspaceMembers(workspaceId), getUserWorkspaces(userId), and mutations: addMember(workspaceId, userId, role), updateMemberRole(membershipId, role), removeMember(membershipId). Implement role-based access control helper isWorkspaceOwner(), isWorkspaceEditor(). Create workspace switcher UI component with dropdown showing user's workspaces. Add 'New Workspace' dialog with name input and slug preview. Show workspace members in settings with role badges (Owner/Editor/Viewer). Implement invite flow with shareable link generation. Auto-create membership with 'owner' role when creating workspace.",
        "testStrategy": "Create workspace and verify slug generation is URL-safe and unique. Test membership creation with different roles. Verify role-based access controls prevent unauthorized actions. Test workspace switching updates UI context. Confirm owner can add/remove members.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create workspace CRUD mutations in Convex",
            "description": "Implement createWorkspace, updateWorkspace, and deleteWorkspace mutations in convex/workspaces.ts with proper validation and authorization checks",
            "dependencies": [],
            "details": "Create convex/workspaces.ts file. Implement createWorkspace(name) mutation that validates name is non-empty, generates slug, creates workspace record with ownerId from auth context, and auto-creates owner membership. Implement updateWorkspace(id, name) mutation with ownership verification and slug regeneration. Implement deleteWorkspace(id) mutation that verifies ownership, cascades deletion to memberships, and returns success status. Add error handling for all mutations with descriptive error messages.",
            "status": "pending",
            "testStrategy": "Test createWorkspace returns workspace with valid ID and slug. Verify updateWorkspace only allows owner to modify. Test deleteWorkspace removes workspace and associated memberships. Confirm non-owners receive authorization errors."
          },
          {
            "id": 2,
            "title": "Implement slug generation with uniqueness validation",
            "description": "Create slug generation utility using nanoid or slugify with database uniqueness checks to ensure URL-safe, collision-free workspace slugs",
            "dependencies": [
              1
            ],
            "details": "Install nanoid@5 package. Create convex/lib/slugs.ts utility module. Implement generateUniqueSlug(name, workspaceId?) function that creates base slug from name using slugify with lowercase and hyphen separator, appends nanoid(6) for uniqueness, queries workspaces table to check for collisions, and retries with new nanoid if collision detected. Add regex validation to ensure slug matches /^[a-z0-9-]+$/ pattern. Export isValidSlug(slug) helper function. Handle edge cases for empty names and special characters.",
            "status": "pending",
            "testStrategy": "Test slug generation creates URL-safe strings. Verify uniqueness by creating multiple workspaces with same name. Test collision detection and retry logic. Confirm special characters are properly sanitized. Validate regex pattern enforcement."
          },
          {
            "id": 3,
            "title": "Create membership management queries and mutations",
            "description": "Implement membership queries (getWorkspaceMembers, getUserWorkspaces) and mutations (addMember, updateMemberRole, removeMember) in convex/memberships.ts",
            "dependencies": [
              1
            ],
            "details": "Create convex/memberships.ts file. Define role enum with 'owner', 'editor', 'viewer' values in schema. Implement getWorkspaceMembers(workspaceId) query that joins with users table and returns array with userId, name, email, role, joinedAt. Implement getUserWorkspaces(userId) query returning workspaces with user's role. Create addMember(workspaceId, userId, role) mutation with owner verification and duplicate check. Implement updateMemberRole(membershipId, role) mutation preventing last owner demotion. Create removeMember(membershipId) mutation with owner check and last-owner protection.",
            "status": "pending",
            "testStrategy": "Test getWorkspaceMembers returns all members with correct roles. Verify getUserWorkspaces shows only user's workspaces. Test addMember prevents duplicate memberships. Confirm updateMemberRole blocks removing last owner. Verify removeMember enforces ownership rules."
          },
          {
            "id": 4,
            "title": "Implement role-based access control helpers",
            "description": "Create RBAC utility functions isWorkspaceOwner, isWorkspaceEditor, and canPerformAction to enforce permission checks across workspace operations",
            "dependencies": [
              3
            ],
            "details": "Create convex/lib/rbac.ts module. Implement isWorkspaceOwner(userId, workspaceId) function that queries memberships table and returns boolean. Create isWorkspaceEditor(userId, workspaceId) function checking for 'owner' or 'editor' role. Implement canPerformAction(userId, workspaceId, action) function with permission matrix mapping actions (create, read, update, delete) to required roles. Add hasWorkspaceAccess(userId, workspaceId) function for basic membership check. Export all helpers for use in mutations and queries. Add comprehensive JSDoc comments explaining permission hierarchy.",
            "status": "pending",
            "testStrategy": "Test isWorkspaceOwner returns true only for owners. Verify isWorkspaceEditor returns true for owners and editors. Test canPerformAction correctly maps actions to roles. Confirm viewers cannot perform write operations. Validate non-members always return false."
          },
          {
            "id": 5,
            "title": "Create workspace switcher UI component",
            "description": "Build workspace switcher dropdown component displaying user's workspaces with navigation and 'New Workspace' action",
            "dependencies": [
              3
            ],
            "details": "Create app/components/WorkspaceSwitcher.tsx component. Use getUserWorkspaces query from convex/memberships.ts to fetch workspaces. Implement dropdown using Radix UI DropdownMenu with trigger showing current workspace name and icon. Map workspaces to menu items with workspace name, slug, and role badge. Add separator before 'New Workspace' action item. Implement workspace switching that updates URL to /workspaces/{slug} and updates context. Style with Tailwind including hover states and active workspace highlight. Add keyboard navigation support (arrow keys, enter). Show loading skeleton while workspaces load.",
            "status": "pending",
            "testStrategy": "Test dropdown opens on click and shows all user workspaces. Verify current workspace is highlighted. Test clicking workspace navigates to correct URL. Confirm 'New Workspace' option triggers dialog. Validate keyboard navigation works correctly. Test loading state displays appropriately."
          },
          {
            "id": 6,
            "title": "Build new workspace dialog with slug preview",
            "description": "Create dialog component for workspace creation with name input and real-time slug preview showing the generated URL-safe slug",
            "dependencies": [
              2,
              5
            ],
            "details": "Create app/components/NewWorkspaceDialog.tsx using Radix UI Dialog. Add controlled input for workspace name with label and validation. Implement useEffect hook that debounces name input (300ms) and generates preview slug using slugify client-side. Display slug preview below input with format '/workspaces/{slug-preview}' in monospace font. Add form submission that calls createWorkspace mutation with name. Show loading state on submit button during mutation. Display error messages for duplicate names or validation failures. Reset form and close dialog on successful creation. Navigate to new workspace after creation.",
            "status": "pending",
            "testStrategy": "Test name input updates slug preview in real-time. Verify debouncing prevents excessive updates. Test form submission creates workspace and navigates. Confirm error handling displays validation messages. Verify dialog closes and resets after successful creation. Test escape key and backdrop click close dialog."
          },
          {
            "id": 7,
            "title": "Implement member management UI in workspace settings",
            "description": "Create settings page section displaying workspace members with role badges, role editing for owners, and member removal capabilities",
            "dependencies": [
              3,
              4
            ],
            "details": "Create app/components/workspace/MemberManagement.tsx component. Use getWorkspaceMembers query to fetch members list. Display table with columns: avatar, name, email, role badge, actions. Render role badges with distinct colors (owner=purple, editor=blue, viewer=gray). For workspace owners, add role dropdown in actions column using Select component. Implement role change handler calling updateMemberRole mutation. Add remove button (trash icon) with confirmation dialog. Disable remove/edit for current user if they're the last owner. Show empty state with invitation prompt when no members. Add loading skeletons for each row during fetch.",
            "status": "pending",
            "testStrategy": "Test member list displays all workspace members correctly. Verify role badges show correct colors. Test owners can change member roles via dropdown. Confirm role updates persist immediately. Verify remove button shows confirmation and deletes member. Test last owner cannot be removed or demoted. Validate non-owners cannot see edit controls."
          },
          {
            "id": 8,
            "title": "Create invite link generation and sharing flow",
            "description": "Implement secure invite link generation with token-based access and UI for copying and sharing workspace invitations",
            "dependencies": [
              3,
              4
            ],
            "details": "Create convex/invites.ts with createInviteLink(workspaceId, role) mutation that generates secure token using nanoid(32), stores invite record with workspaceId, role, createdBy, expiresAt (7 days), and returns shareable URL. Add acceptInvite(token) mutation that validates token, checks expiration, creates membership, and marks invite as used. Create app/components/workspace/InviteDialog.tsx with role selector and 'Generate Link' button. Display generated link in copyable input with copy-to-clipboard button. Add expiration timer showing days remaining. Implement app/routes/invite/$token.tsx route that calls acceptInvite and redirects to workspace on success.",
            "status": "pending",
            "testStrategy": "Test createInviteLink generates unique tokens. Verify invite URL format is correct. Test copy button copies full URL to clipboard. Confirm acceptInvite creates membership with correct role. Test expired tokens are rejected. Verify used tokens cannot be reused. Test unauthenticated users are prompted to login before accepting."
          }
        ]
      },
      {
        "id": 9,
        "title": "Firecrawl API integration for event page extraction",
        "description": "Integrate Firecrawl API to extract and parse event page content into structured data for tasks and calendar events",
        "details": "Install axios@latest for HTTP requests. Create app/lib/firecrawl.ts with extractEventPage(url: string) function. Call Firecrawl scrape endpoint: POST https://api.firecrawl.dev/v0/scrape with headers: Authorization: Bearer {FIRECRAWL_API_KEY}, body: { url, pageOptions: { onlyMainContent: true }, extractorOptions: { mode: 'llm-extraction', extractionPrompt: 'Extract hackathon/event details: title, description, deadlines, submission dates, judging dates, prize info, rules, judges, social handles, hashtags' } }. Parse response JSON and extract markdown and structured data. Implement error handling for rate limits (429), invalid URLs (400), and timeouts. Add retry logic with exponential backoff (3 attempts). Return normalized structure: { title, description, sections: [{type, content, metadata}], dates: [{text, isoDate, type}], contacts: [{name, role, links}] }. Log extraction quality metrics to Sentry.",
        "testStrategy": "Test extraction with sample Luma, Devpost, and Lu.ma event URLs. Verify structured data extraction includes dates, deadlines, and rules. Test error handling for invalid URLs and API failures. Confirm retry logic executes on transient errors. Validate rate limit handling.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install axios and define Firecrawl client types",
            "description": "Install axios HTTP client library and create TypeScript type definitions for Firecrawl API requests and responses",
            "dependencies": [],
            "details": "Run npm install axios@latest. Create app/lib/firecrawl.ts with TypeScript interfaces: FirecrawlScrapeRequest { url: string, pageOptions: { onlyMainContent: boolean }, extractorOptions: { mode: 'llm-extraction', extractionPrompt: string } }, FirecrawlScrapeResponse { success: boolean, markdown?: string, metadata?: any, error?: string }, ExtractedEventData { title: string, description: string, sections: Section[], dates: EventDate[], contacts: Contact[] }. Define Section { type: string, content: string, metadata?: any }, EventDate { text: string, isoDate?: string, type: 'deadline' | 'submission' | 'judging' | 'other' }, Contact { name: string, role?: string, links: string[] }.",
            "status": "pending",
            "testStrategy": "Verify axios is installed in package.json. Compile TypeScript to ensure all type definitions are valid with no errors."
          },
          {
            "id": 2,
            "title": "Implement Firecrawl API client with LLM extraction mode",
            "description": "Create extractEventPage function that calls Firecrawl scrape endpoint with LLM extraction configuration",
            "dependencies": [
              1
            ],
            "details": "In app/lib/firecrawl.ts, implement async function extractEventPage(url: string): Promise<ExtractedEventData>. Construct POST request to https://api.firecrawl.dev/v0/scrape with headers: { 'Authorization': `Bearer ${process.env.FIRECRAWL_API_KEY}`, 'Content-Type': 'application/json' }. Request body: { url, pageOptions: { onlyMainContent: true }, extractorOptions: { mode: 'llm-extraction', extractionPrompt: 'Extract hackathon/event details including: title, description, all deadlines (submission, judging, etc.), prize information, rules, judges, social media handles, and hashtags. Return structured data.' } }. Use axios.post with timeout of 30 seconds. Validate FIRECRAWL_API_KEY exists before making request.",
            "status": "pending",
            "testStrategy": "Test with valid Devpost and Luma event URLs. Verify Authorization header is set correctly. Confirm request body matches expected format. Test that missing API key throws error before request."
          },
          {
            "id": 3,
            "title": "Parse and normalize Firecrawl response into structured schema",
            "description": "Transform raw Firecrawl API response into normalized ExtractedEventData structure with validated fields",
            "dependencies": [
              2
            ],
            "details": "Parse FirecrawlScrapeResponse JSON. Extract title and description from response.metadata or response.markdown. Parse sections array from extracted data, normalizing each to { type, content, metadata } format. Extract dates array and normalize to EventDate format with text, isoDate (parse using date-fns if possible), and type classification (deadline/submission/judging/other). Extract contacts with name, role, and links. Handle missing or malformed fields gracefully with defaults. Validate required fields (title, description) are present. If markdown contains structured data, parse it into sections.",
            "status": "pending",
            "testStrategy": "Test parsing with mock Firecrawl responses containing various data structures. Verify all required fields are extracted. Test with missing optional fields returns valid structure. Confirm date parsing handles various formats. Validate contacts array handles missing role/links."
          },
          {
            "id": 4,
            "title": "Implement error handling for API failure modes",
            "description": "Add comprehensive error handling for rate limits, invalid URLs, timeouts, and API errors with proper error types",
            "dependencies": [
              2
            ],
            "details": "Create custom error classes: FirecrawlRateLimitError (429), FirecrawlInvalidUrlError (400), FirecrawlTimeoutError, FirecrawlApiError. Wrap axios call in try-catch. Check response.status: if 429 throw FirecrawlRateLimitError with retry-after header; if 400 throw FirecrawlInvalidUrlError; if timeout throw FirecrawlTimeoutError. Catch AxiosError and map to appropriate custom error. For non-200 responses, throw FirecrawlApiError with status and message. Check response.success field and throw if false. Validate response structure before parsing.",
            "status": "pending",
            "testStrategy": "Mock axios to return 429 and verify FirecrawlRateLimitError thrown. Test 400 response throws FirecrawlInvalidUrlError. Simulate timeout and confirm FirecrawlTimeoutError. Test invalid response structure throws FirecrawlApiError. Verify error messages include helpful context."
          },
          {
            "id": 5,
            "title": "Add retry logic with exponential backoff",
            "description": "Implement retry mechanism with exponential backoff strategy for transient failures, supporting up to 3 attempts",
            "dependencies": [
              4
            ],
            "details": "Create async function withRetry<T>(fn: () => Promise<T>, maxAttempts = 3): Promise<T>. Implement retry loop with attempt counter. Calculate backoff delay: Math.min(1000 * Math.pow(2, attempt), 10000) for exponential backoff capped at 10s. Retry on FirecrawlRateLimitError, FirecrawlTimeoutError, and 5xx errors. Do NOT retry on FirecrawlInvalidUrlError or 4xx client errors. Use setTimeout/Promise for delay between attempts. Log each retry attempt with attempt number and delay. Throw final error if all attempts exhausted. Wrap extractEventPage API call with withRetry.",
            "status": "pending",
            "testStrategy": "Mock API to fail twice then succeed, verify function returns after 3 attempts. Test exponential backoff delays are correct (1s, 2s, 4s). Confirm 400 errors do not trigger retry. Verify 429 and timeout errors trigger retry. Test maxAttempts=3 throws after 3 failures."
          },
          {
            "id": 6,
            "title": "Configure timeout handling for API requests",
            "description": "Set appropriate timeout configuration for Firecrawl API calls and handle timeout scenarios gracefully",
            "dependencies": [
              2,
              4
            ],
            "details": "Configure axios request with timeout: 30000 (30 seconds) in axios.post config. Add AbortController for manual cancellation support. In timeout catch block, throw FirecrawlTimeoutError with message indicating 30s limit exceeded. Log timeout events with URL and duration to Sentry. Consider adding configurable timeout via environment variable FIRECRAWL_TIMEOUT_MS with 30000 default. Ensure timeout errors are properly caught and wrapped in retry logic.",
            "status": "pending",
            "testStrategy": "Mock slow API response exceeding 30s and verify FirecrawlTimeoutError thrown. Test that timeout error triggers retry logic. Confirm Sentry receives timeout event logs. Verify configurable timeout via env var works correctly."
          },
          {
            "id": 7,
            "title": "Implement extraction quality metrics logging to Sentry",
            "description": "Add monitoring and quality metrics for extraction results, logging success rates and data completeness to Sentry",
            "dependencies": [
              3
            ],
            "details": "Import Sentry from app/lib/sentry.server.ts. After successful extraction, calculate quality metrics: fieldsExtracted (count of non-null/non-empty fields), sectionsCount, datesCount, contactsCount, hasTitle (boolean), hasDescription (boolean). Calculate completeness score: (fieldsExtracted / totalExpectedFields) * 100. Log to Sentry using Sentry.captureMessage with level 'info' and extra context: { url, completenessScore, fieldsExtracted, sectionsCount, datesCount, contactsCount, extractionDurationMs }. For failures, log error with Sentry.captureException including url and error type. Add Sentry breadcrumb before extraction starts.",
            "status": "pending",
            "testStrategy": "Extract test event page and verify Sentry receives quality metrics event. Confirm completeness score calculated correctly. Test failed extraction logs error to Sentry with URL. Verify breadcrumbs appear in Sentry event trail. Check metrics include all expected fields."
          },
          {
            "id": 8,
            "title": "Define and export structured data schema with validation",
            "description": "Create comprehensive TypeScript schema definition for extracted event data with runtime validation",
            "dependencies": [
              1,
              3
            ],
            "details": "Export all TypeScript interfaces from app/lib/firecrawl.ts: ExtractedEventData, Section, EventDate, Contact. Add JSDoc comments documenting each field and expected format. Create validation function validateExtractedData(data: any): ExtractedEventData that checks: title is non-empty string, description is non-empty string, sections is array, dates is array with valid EventDate objects, contacts is array. Throw descriptive errors for invalid data. Optionally install zod for schema validation. Export validator alongside types. Use validator in extractEventPage before returning data.",
            "status": "pending",
            "testStrategy": "Import types in another module and verify they compile correctly. Test validateExtractedData with valid data returns true. Test with missing title throws validation error. Verify invalid date format is caught. Confirm exported types are usable in Convex mutations."
          }
        ]
      },
      {
        "id": 10,
        "title": "Import mapping logic for tasks and events creation",
        "description": "Build intelligent mapping system to convert Firecrawl extracted data into actionable tasks and calendar events with proper categorization",
        "details": "Create app/lib/importMapper.ts with mapExtractedDataToWorkspace(extracted, workspaceId). Implement date detection using chrono-node@latest library to parse natural language dates ('Nov 17, 2025 12:00 PM PT'). Normalize all dates to ISO-8601 UTC with sourceTz metadata. Create task mapping rules: sections containing 'submission'/'deadline'/'due' → calendar events with endAt; 'judging'/'criteria'/'prize'/'rules' → compliance tasks; social callouts (@mentions, #hashtags) → social tasks; technical requirements → implementation tasks. Assign task priorities: deadlines within 7 days = 'high', within 14 days = 'medium', else 'low'. Generate task titles from section headers and first sentence. Extract contacts from 'judges', 'mentors', 'speakers' sections. Create fallback logic: if no dates found, prompt user for submission date and create generic milestone tasks. Return mapped structure: { events: [{title, startAt, endAt, url}], tasks: [{title, description, priority, labels, dueAt}], contacts: [{name, email, links}] }.",
        "testStrategy": "Test mapping with various event page structures. Verify date parsing handles multiple formats and timezones correctly. Confirm task categorization creates appropriate labels. Test fallback logic when no dates detected. Validate contact extraction from judge/mentor sections.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure chrono-node date parsing library",
            "description": "Set up chrono-node@latest for natural language date extraction from event pages with timezone awareness",
            "dependencies": [],
            "details": "Install chrono-node@latest via npm. Create app/lib/dateParser.ts with parseDateString(text: string, referenceDate?: Date) function that uses chrono.parse() with strict mode. Configure timezone-aware parsing to handle formats like 'Nov 17, 2025 12:00 PM PT', 'March 15th at 3pm EST', '2025-06-01'. Return parsed results with original text, parsed date, and detected timezone. Handle edge cases: relative dates ('next Friday'), ambiguous formats ('3/4/2025'), missing timezones (default to UTC).",
            "status": "pending",
            "testStrategy": "Test with various date formats: 'Nov 17, 2025 12:00 PM PT', 'tomorrow at 3pm', '2025-03-15T14:00:00Z'. Verify timezone detection. Test invalid dates return null. Confirm relative dates parse correctly with reference date."
          },
          {
            "id": 2,
            "title": "Implement ISO-8601 UTC normalization with timezone metadata",
            "description": "Build date normalization system that converts all parsed dates to ISO-8601 UTC format while preserving source timezone information",
            "dependencies": [
              1
            ],
            "details": "Create normalizeDateToISO(parsedDate: ChronoDate) function in app/lib/dateParser.ts. Convert parsed date to UTC using date-fns-tz library. Store original timezone as metadata: { isoDate: string, sourceTz: string, originalText: string }. Handle timezone abbreviations (PT→America/Los_Angeles, EST→America/New_York) using mapping table. For dates without timezone, default to UTC and set sourceTz='UTC'. Implement validation to ensure output is valid ISO-8601 format (YYYY-MM-DDTHH:mm:ss.sssZ).",
            "status": "pending",
            "testStrategy": "Test 'Nov 17, 2025 12:00 PM PT' converts to '2025-11-17T20:00:00.000Z' with sourceTz='America/Los_Angeles'. Verify UTC dates preserve sourceTz='UTC'. Test invalid timezones fallback to UTC. Confirm ISO-8601 format validation."
          },
          {
            "id": 3,
            "title": "Build task categorization rules engine",
            "description": "Create intelligent categorization system to classify content sections into submission events, compliance tasks, social tasks, and implementation tasks",
            "dependencies": [],
            "details": "Create app/lib/categoryEngine.ts with categorizeSection(section: ExtractedSection) function. Implement keyword-based rules: if section contains ['submission', 'deadline', 'due'] → type='calendar_event'; ['judging', 'criteria', 'prize', 'rules'] → type='compliance_task' with label='compliance'; [@mentions, #hashtags] → type='social_task' with label='social_media'; ['API', 'backend', 'frontend', 'database'] → type='implementation_task' with label='technical'. Use case-insensitive matching. Support multi-label assignment if section matches multiple categories. Return { type, labels[], confidence }.",
            "status": "pending",
            "testStrategy": "Test section with 'Submission deadline: Nov 17' returns type='calendar_event'. Verify 'Judging criteria' returns type='compliance_task' with label='compliance'. Test '@johndoe submit PR' returns type='social_task' with label='social_media'. Confirm technical keywords trigger implementation_task."
          },
          {
            "id": 4,
            "title": "Implement priority assignment algorithm",
            "description": "Create priority calculation system based on deadline proximity: high for <7 days, medium for <14 days, low for everything else",
            "dependencies": [
              2
            ],
            "details": "Create calculatePriority(dueAt: string) function in app/lib/priorityEngine.ts. Calculate days until deadline: daysUntil = (new Date(dueAt) - new Date()) / (1000 * 60 * 60 * 24). Apply rules: if daysUntil < 7 return 'high'; if daysUntil < 14 return 'medium'; else return 'low'. Handle edge cases: if dueAt is null return 'medium', if dueAt is in past return 'high' (urgent). For events with both startAt and endAt, use endAt for priority calculation. Store priority metadata with reason: { priority: 'high', reason: 'Due in 3 days' }.",
            "status": "pending",
            "testStrategy": "Test deadline in 3 days returns 'high'. Test deadline in 10 days returns 'medium'. Test deadline in 30 days returns 'low'. Verify null deadline returns 'medium'. Confirm past deadline returns 'high'."
          },
          {
            "id": 5,
            "title": "Build contact extraction from specific sections",
            "description": "Extract contacts from judges, mentors, speakers sections with name, email, and profile links",
            "dependencies": [],
            "details": "Create app/lib/contactExtractor.ts with extractContacts(sections: ExtractedSection[]) function. Filter sections with headers matching ['judges', 'mentors', 'speakers', 'organizers', 'team']. Use regex patterns: emails /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z0-9_-]+)/gi, URLs /https?:\\/\\/[^\\s]+/gi. Extract names from text before email or from list items. Parse social links: LinkedIn, Twitter, GitHub. Return { contacts: [{ name, email?, links: { linkedin?, twitter?, github? } }] }. Handle malformed data gracefully.",
            "status": "pending",
            "testStrategy": "Test 'Judges: John Doe (john@example.com, linkedin.com/in/johndoe)' extracts name, email, LinkedIn. Verify multiple contacts parsed. Test section without emails returns empty array. Confirm malformed emails ignored."
          },
          {
            "id": 6,
            "title": "Implement event mapping with start and end times",
            "description": "Map extracted data to calendar events with startAt and endAt timestamps for submissions and deadlines",
            "dependencies": [
              2,
              3
            ],
            "details": "Create mapToEvents(sections: ExtractedSection[]) function in app/lib/importMapper.ts. Filter sections where categorizeSection() returns type='calendar_event'. For each section: extract dates using parseDateString(), normalize to ISO-8601. If section contains 'deadline' or 'due', set endAt to parsed date and startAt to null. If section contains time range ('10am-2pm'), parse both as startAt and endAt. Generate title from section header or first sentence (max 100 chars). Include source URL. Return array: [{ title, startAt?, endAt, url, metadata }].",
            "status": "pending",
            "testStrategy": "Test 'Submission deadline: Nov 17, 2025 12:00 PM PT' creates event with endAt='2025-11-17T20:00:00.000Z'. Verify time range '10am-2pm Nov 15' creates startAt and endAt. Confirm title extracted from header. Test missing dates return null."
          },
          {
            "id": 7,
            "title": "Implement task mapping with priority and labels",
            "description": "Map extracted data to tasks with titles, descriptions, priorities, labels, and due dates based on categorization rules",
            "dependencies": [
              3,
              4
            ],
            "details": "Create mapToTasks(sections: ExtractedSection[]) function in app/lib/importMapper.ts. For each section where categorizeSection() returns type ending in '_task': generate title from section header or first sentence (5-100 chars). Use section body as description (strip HTML, max 500 chars). Apply calculatePriority() if dueAt detected. Add labels from categorization (compliance, social_media, technical). Extract dueAt from dates in section. Include source URL. Return array: [{ title, description, priority, labels[], dueAt?, url }].",
            "status": "pending",
            "testStrategy": "Test 'Judging criteria: Submit code by Nov 20' creates compliance_task with dueAt, priority='high', label='compliance'. Verify social section creates social_task. Test technical keywords add 'technical' label. Confirm title and description extracted."
          },
          {
            "id": 8,
            "title": "Create fallback logic for missing dates",
            "description": "Implement fallback system that prompts users for submission date and generates generic milestone tasks when no dates are detected",
            "dependencies": [
              1,
              2
            ],
            "details": "Create handleMissingDates(sections: ExtractedSection[]) function in app/lib/importMapper.ts. Detect if parseDateString() returns no dates across all sections. Return metadata flag: { noDatesDetected: true, suggestedPrompt: 'What is the submission deadline?' }. If user provides fallback date, generate milestone tasks: 'Research phase' (30 days before deadline), 'Development sprint' (14 days before), 'Testing & refinement' (7 days before), 'Final submission' (deadline day). Each milestone gets priority based on proximity. Include note: 'Auto-generated milestone - please review'.",
            "status": "pending",
            "testStrategy": "Test extraction with no dates returns noDatesDetected=true. Verify fallback date '2025-12-01' generates 4 milestone tasks. Confirm milestones have correct relative dates (30d, 14d, 7d, 0d before deadline). Test priorities assigned correctly."
          },
          {
            "id": 9,
            "title": "Define structured output schema and edge case handling",
            "description": "Create TypeScript interfaces for mapper output and implement comprehensive error handling for malformed data, duplicate items, and validation failures",
            "dependencies": [
              5,
              6,
              7,
              8
            ],
            "details": "Create app/lib/importMapper.ts with TypeScript types: MappedEvent { title, startAt?, endAt, url, metadata }, MappedTask { title, description, priority, labels[], dueAt?, url }, MappedContact { name, email?, links }, MapperOutput { events, tasks, contacts, noDatesDetected?, errors[] }. Implement mapExtractedDataToWorkspace(extracted: ExtractedData, workspaceId: string): MapperOutput. Handle edge cases: deduplicate events/tasks by title+date, validate required fields (title min 5 chars), catch parsing errors and add to errors[] array, limit output to max 100 items per type. Log warnings for skipped items.",
            "status": "pending",
            "testStrategy": "Test valid extraction returns MapperOutput with populated events/tasks/contacts. Verify duplicate events removed. Test invalid titles (too short) added to errors[]. Confirm max 100 items per type enforced. Test malformed data doesn't crash, returns partial results with errors."
          }
        ]
      },
      {
        "id": 11,
        "title": "Streaming import endpoint with real-time progress logs",
        "description": "Implement server-sent events endpoint to stream import progress with step-by-step logging during extraction and mapping",
        "details": "Create app/routes/api/import.start.ts server function accepting { url, turnstileToken, workspaceId }. Validate Turnstile, then create import record in Convex with status 'queued'. Spawn async Convex action imports.process(importId). Create app/routes/api/import.stream.ts using TanStack Start's streaming response API. Implement SSE (Server-Sent Events) with EventSource on client. In imports.process action: (1) Update status to 'running', append log 'Fetching page...', (2) Call Firecrawl API, append log 'Extracting content...', (3) Parse response, append log 'Found X deadlines, Y sections...', (4) Run mapping logic, append log 'Generating tasks...', (5) Batch insert events and tasks to Convex, append log 'Created Z tasks and W events', (6) Update status to 'done'. Stream logs via SSE as newline-delimited JSON: data: {ts, level, msg}. Handle errors by updating status to 'error' and streaming error message. Implement timeout of 60s for entire operation.",
        "testStrategy": "Initiate import and verify SSE connection streams logs in real-time. Confirm at least 5 distinct log steps appear. Test error handling streams error message. Verify import record updates to 'done' status. Test timeout triggers after 60s. Confirm UI updates with streamed logs.",
        "priority": "high",
        "dependencies": [
          7,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create import.start.ts endpoint with Turnstile validation",
            "description": "Implement the initial import endpoint that accepts url, turnstileToken, and workspaceId, validates the Turnstile token, and creates an import record in Convex with 'queued' status",
            "dependencies": [],
            "details": "Create app/routes/api/import.start.ts server function. Accept POST request with { url, turnstileToken, workspaceId } payload. Validate Turnstile token by calling Cloudflare API with CLOUDFLARE_TURNSTILE_SECRET. Return 401 if validation fails. Create import record in Convex imports table with fields: { url, workspaceId, status: 'queued', createdAt, logs: [] }. Return { importId } response. Handle errors with appropriate status codes and error messages.",
            "status": "pending",
            "testStrategy": "Send POST request with valid Turnstile token and verify import record created with 'queued' status. Test invalid token returns 401. Verify importId returned in response. Confirm error handling for missing fields."
          },
          {
            "id": 2,
            "title": "Implement Convex imports.process async action",
            "description": "Create the core Convex action that orchestrates the entire import workflow including fetching, parsing, mapping, and inserting data with status updates",
            "dependencies": [
              1
            ],
            "details": "Create convex/imports.ts with async action imports.process(importId). Implement state machine: (1) Update status to 'running' and append log 'Fetching page...', (2) Call Firecrawl API with url from import record, append log 'Extracting content...', (3) Parse Firecrawl response, count deadlines/sections, append log 'Found X deadlines, Y sections...', (4) Call mapExtractedDataToWorkspace from task 10, append log 'Generating tasks...', (5) Batch insert events and tasks to Convex, append log 'Created Z tasks and W events', (6) Update status to 'done'. Each log entry includes timestamp and level fields. Handle errors by updating status to 'error' and appending error message to logs.",
            "status": "pending",
            "testStrategy": "Trigger action with test importId and verify status progresses from 'queued' to 'running' to 'done'. Confirm logs array contains at least 5 entries. Test error scenario updates status to 'error'. Verify tasks and events created in database."
          },
          {
            "id": 3,
            "title": "Create import.stream.ts SSE endpoint with TanStack Start",
            "description": "Implement Server-Sent Events endpoint using TanStack Start's streaming response API to stream import progress logs in real-time",
            "dependencies": [
              2
            ],
            "details": "Create app/routes/api/import.stream.ts using TanStack Start's streaming response utilities. Accept GET request with importId query parameter. Set headers: 'Content-Type: text/event-stream', 'Cache-Control: no-cache', 'Connection: keep-alive'. Query Convex import record and stream existing logs immediately. Subscribe to Convex reactive query for import record changes. When logs update, send SSE message in format: 'data: {\"ts\":\"2025-01-15T10:30:00Z\",\"level\":\"info\",\"msg\":\"Fetching page...\"}\\n\\n'. When status becomes 'done' or 'error', send final message and close stream. Implement heartbeat every 15s to keep connection alive.",
            "status": "pending",
            "testStrategy": "Connect to stream endpoint with test importId and verify SSE messages arrive. Confirm messages are newline-delimited JSON. Test stream closes when import completes. Verify heartbeat messages prevent timeout. Test multiple concurrent connections."
          },
          {
            "id": 4,
            "title": "Implement EventSource client for SSE consumption",
            "description": "Create client-side EventSource implementation to connect to the SSE endpoint and handle incoming log messages with automatic reconnection",
            "dependencies": [
              3
            ],
            "details": "Create app/lib/importStream.ts with useImportStream(importId) hook. Initialize EventSource to '/api/import.stream?importId={importId}'. Parse incoming SSE messages as JSON. Store logs in local state array. Handle 'open', 'message', and 'error' events. Implement automatic reconnection on connection loss with exponential backoff (1s, 2s, 4s, max 8s). Close EventSource when status becomes 'done' or 'error'. Return { logs, status, error, isConnected } from hook. Clean up EventSource on unmount to prevent memory leaks.",
            "status": "pending",
            "testStrategy": "Test hook connects to SSE endpoint and receives messages. Verify logs array updates reactively. Test reconnection logic after simulated connection drop. Confirm EventSource closes on component unmount. Verify error state set on stream error."
          },
          {
            "id": 5,
            "title": "Design import status state machine in Convex schema",
            "description": "Define the import record schema and status state machine with proper transitions and validation rules",
            "dependencies": [],
            "details": "Update convex/schema.ts to add imports table with fields: { url: v.string(), workspaceId: v.id('workspaces'), status: v.union(v.literal('queued'), v.literal('running'), v.literal('done'), v.literal('error')), logs: v.array(v.object({ ts: v.string(), level: v.string(), msg: v.string() })), createdAt: v.number(), completedAt: v.optional(v.number()), error: v.optional(v.string()) }. Add index on workspaceId for efficient querying. Create helper mutation imports.updateStatus(importId, status, log?) that validates status transitions: queued→running, running→done, running→error. Prevent invalid transitions like done→running. Append log entry if provided.",
            "status": "pending",
            "testStrategy": "Create import record and verify schema validation. Test updateStatus mutation with valid transitions. Confirm invalid transitions rejected. Verify logs array appends correctly. Test index improves query performance for workspace imports."
          },
          {
            "id": 6,
            "title": "Implement step-by-step logging at each import phase",
            "description": "Add comprehensive logging throughout the import process with structured log entries including timestamps, levels, and contextual information",
            "dependencies": [
              2,
              5
            ],
            "details": "In imports.process action, create appendLog(importId, level, msg) helper that adds { ts: new Date().toISOString(), level, msg } to logs array. Add log entries at key points: (1) 'Fetching page...' before Firecrawl call, (2) 'Extracting content...' after receiving response, (3) 'Found X deadlines, Y sections...' after parsing with actual counts, (4) 'Generating tasks...' before mapping, (5) 'Mapping to workspace structure...' during mapping, (6) 'Created Z tasks and W events' after insertion with actual counts, (7) 'Import complete' when done. Use level 'info' for progress, 'warn' for recoverable issues, 'error' for failures. Include execution time in final log.",
            "status": "pending",
            "testStrategy": "Run import and verify logs array contains all 7+ expected entries. Confirm timestamps are sequential. Test log levels match event types. Verify counts in messages match actual database inserts. Check final log includes execution time."
          },
          {
            "id": 7,
            "title": "Implement error handling with status updates and error streaming",
            "description": "Add comprehensive error handling throughout the import pipeline with proper error messages streamed to the client",
            "dependencies": [
              2,
              3,
              6
            ],
            "details": "Wrap imports.process action in try-catch. Catch Firecrawl API errors (rate limit, invalid URL, timeout) and append specific error logs. Catch mapping errors and log parsing failures with details. Catch database insertion errors and log transaction failures. On any error, update status to 'error', set error field with error message, append log with level 'error'. In SSE endpoint, stream error logs immediately. On client, display error messages in UI with red styling. Implement retry mechanism: allow user to retry failed imports from 'error' status by resetting to 'queued'. Log all retries with attempt number.",
            "status": "pending",
            "testStrategy": "Test Firecrawl API failure updates status to 'error' and streams error message. Verify mapping errors logged with details. Test database errors handled gracefully. Confirm client displays error messages. Test retry mechanism resets status and logs retry attempt."
          },
          {
            "id": 8,
            "title": "Implement 60-second timeout for import operation",
            "description": "Add timeout mechanism to prevent imports from running indefinitely and ensure proper cleanup on timeout",
            "dependencies": [
              2,
              7
            ],
            "details": "In imports.process action, wrap main logic with Promise.race against timeout promise (60s). If timeout wins, update status to 'error', append log 'Import timed out after 60s', and throw timeout error. Ensure all resources (Firecrawl connections, database transactions) are properly cleaned up on timeout. In import.start.ts, spawn imports.process as fire-and-forget action to avoid blocking HTTP request. Add timeoutAt field to import record set to createdAt + 60000ms. Create scheduled Convex cron job that runs every minute to find imports with status 'running' and timeoutAt < now, then update them to 'error' with timeout message.",
            "status": "pending",
            "testStrategy": "Trigger import with slow/unresponsive Firecrawl mock and verify timeout triggers after 60s. Confirm status updates to 'error' and timeout message logged. Test cron job catches stuck imports. Verify resources cleaned up properly. Test normal imports complete before timeout."
          },
          {
            "id": 9,
            "title": "Build client-side log streaming UI component",
            "description": "Create a React component that displays streaming import logs in real-time with proper styling and user feedback",
            "dependencies": [
              4
            ],
            "details": "Create app/components/ImportLogsViewer.tsx component accepting importId prop. Use useImportStream hook to get logs, status, error. Render logs in a scrollable container with auto-scroll to bottom on new entries. Style log entries with timestamp (gray), level badge (blue for info, yellow for warn, red for error), and message. Show loading spinner when status is 'queued' or 'running'. Display success message with checkmark when status is 'done'. Show error alert when status is 'error' with retry button. Add connection status indicator (green dot when connected, red when disconnected). Implement log filtering by level. Style with Tailwind classes for consistent theming.",
            "status": "pending",
            "testStrategy": "Render component with test importId and verify logs display in real-time. Test auto-scroll to bottom on new entries. Confirm level badges show correct colors. Test success and error states render properly. Verify retry button triggers new import. Test log filtering works."
          },
          {
            "id": 10,
            "title": "Integrate real-time progress display in import workflow UI",
            "description": "Connect the import flow UI to the streaming logs component and provide seamless user experience from initiation to completion",
            "dependencies": [
              1,
              9
            ],
            "details": "Update import initiation UI (wherever user triggers import) to call import.start.ts endpoint. On successful response, redirect to /imports/{importId} route that renders ImportLogsViewer component. Show progress bar that animates based on log count (estimate 7 total steps). Display current step extracted from latest log message. Add cancel button that calls imports.cancel(importId) mutation to set status to 'error' with message 'Cancelled by user'. On completion, show 'View imported tasks' button that navigates to workspace task list. On error, show 'Try again' button that creates new import with same URL. Persist import history in workspace for user to review past imports.",
            "status": "pending",
            "testStrategy": "Initiate import and verify redirect to logs page. Confirm progress bar updates with each log entry. Test current step displays correctly. Verify cancel button stops import. Test completion button navigates to tasks. Confirm error retry creates new import. Verify import history persists."
          }
        ]
      },
      {
        "id": 12,
        "title": "Import preview and confirmation UI",
        "description": "Build import preview interface allowing users to review, edit, and selectively confirm extracted tasks and events before workspace creation",
        "details": "Create app/routes/import.tsx with multi-step form: (1) URL input with Turnstile widget, (2) Streaming logs display, (3) Preview panel with editable checklist. Use TanStack Form for state management. Implement streaming logs component that connects to /api/import.stream SSE endpoint and appends messages with timestamps and color-coded levels (info=blue, success=green, error=red). When status='done', fetch mapped data and render preview: events list (title, date, editable), tasks list (title, description, priority badge, editable, checkbox to include/exclude), contacts list (name, role). Add inline editing with contentEditable or form inputs. Implement 'Edit' and 'Delete' actions per item. Add 'Create Plan' button that filters selected items and calls Convex mutation to batch insert. Show loading spinner during insertion. Redirect to /tasks on success with toast notification 'Workspace created with X tasks and Y events'.",
        "testStrategy": "Import a test URL and verify preview shows extracted items. Test inline editing updates item data. Confirm deselecting items excludes them from creation. Verify 'Create Plan' inserts only selected items. Test error state if insertion fails. Confirm redirect to tasks page on success.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create multi-step form structure with TanStack Form",
            "description": "Set up the base multi-step form architecture in app/routes/import.tsx using TanStack Form to manage state across three steps: URL input, streaming logs, and preview panel",
            "dependencies": [],
            "details": "Install @tanstack/react-form@latest. Create import.tsx route with useForm() hook managing stepIndex state (0=URL, 1=logs, 2=preview). Define form schema with fields: url, selectedTasks[], selectedEvents[], selectedContacts[]. Implement step navigation functions (nextStep, prevStep) with validation. Create StepIndicator component showing current progress. Set up form context provider wrapping all step components. Configure form persistence in sessionStorage to prevent data loss on refresh.",
            "status": "pending",
            "testStrategy": "Verify form initializes with step 0. Test step navigation updates UI correctly. Confirm form state persists across steps. Verify sessionStorage retains data on page refresh."
          },
          {
            "id": 2,
            "title": "Build URL input step with Turnstile integration",
            "description": "Implement the first form step with URL input field and Cloudflare Turnstile verification widget for bot protection",
            "dependencies": [
              1
            ],
            "details": "Create URLInputStep component with controlled input bound to form.url field. Add URL validation using zod schema (must be valid https URL). Install @marsidev/react-turnstile@latest and add Turnstile widget below input field with sitekey from environment. Store turnstile token in form state. Implement submit handler that validates URL and token, then triggers /api/import.stream connection and advances to step 1. Add error states for invalid URL or failed verification. Style with Tailwind using consistent form patterns.",
            "status": "pending",
            "testStrategy": "Test URL validation rejects invalid formats. Verify Turnstile widget loads and generates token. Confirm submit disabled until both URL valid and Turnstile completed. Test error messages display for validation failures."
          },
          {
            "id": 3,
            "title": "Implement streaming logs display component with SSE",
            "description": "Create real-time log viewer that connects to SSE endpoint and displays color-coded streaming messages during import processing",
            "dependencies": [
              1
            ],
            "details": "Create StreamingLogsStep component using EventSource to connect to /api/import.stream with url and turnstile token as query params. Maintain logs array in component state, appending each SSE message. Parse message format: {level, message, timestamp, status}. Render logs with timestamps in gray, messages color-coded by level (info=blue-600, success=green-600, error=red-600). Implement auto-scroll to bottom on new messages using useEffect with scrollIntoView. When status='done' event received, close EventSource and trigger data fetch from /api/import.data. Handle connection errors with retry logic (max 3 attempts). Add loading spinner at top during connection.",
            "status": "pending",
            "testStrategy": "Test SSE connection establishes successfully. Verify messages append in real-time with correct colors. Confirm auto-scroll follows new messages. Test connection closes on 'done' status. Verify error handling on connection failure."
          },
          {
            "id": 4,
            "title": "Build preview panel UI for events, tasks, and contacts",
            "description": "Design and implement the preview interface displaying extracted events, tasks, and contacts in organized, scannable lists with metadata badges",
            "dependencies": [
              3
            ],
            "details": "Create PreviewPanelStep component with three sections: Events, Tasks, Contacts. Fetch mapped data from /api/import.data when step loads. Render EventsList showing title, formatted date (using date-fns format), and timezone badge. Render TasksList with title, truncated description (max 100 chars), and priority badge (high=red, medium=yellow, low=green). Render ContactsList with name and role. Use card-based layout with Tailwind, grouping items by type. Add section headers with item counts ('Tasks (12)'). Implement empty states when no items in category. Add loading skeleton while fetching data.",
            "status": "pending",
            "testStrategy": "Verify all three sections render with correct data structure. Test date formatting shows human-readable format. Confirm priority badges use correct colors. Verify empty states display when categories have no items. Test loading state shows before data loads."
          },
          {
            "id": 5,
            "title": "Add inline editing functionality for preview items",
            "description": "Implement contentEditable or input-based inline editing allowing users to modify event, task, and contact details before creation",
            "dependencies": [
              4
            ],
            "details": "Add Edit button to each item card. On click, toggle edit mode state for that item. In edit mode: replace title/description text with input fields, preserve character limits (title 200 chars, description 500 chars), add Save/Cancel buttons. Use form.setValue() to update TanStack Form state on Save. For events: allow editing title and date (use datetime-local input). For tasks: allow editing title, description, and priority (dropdown). For contacts: allow editing name and role. Validate changes before saving (required fields, date formats). Revert to view mode on Cancel. Add visual indicator (border highlight) for items in edit mode.",
            "status": "pending",
            "testStrategy": "Test Edit button toggles edit mode correctly. Verify input fields populate with current values. Confirm Save updates form state and exits edit mode. Test Cancel reverts changes. Verify validation prevents saving invalid data."
          },
          {
            "id": 6,
            "title": "Implement item selection with checkboxes",
            "description": "Add checkbox controls to each preview item enabling users to selectively include or exclude items from workspace creation",
            "dependencies": [
              4
            ],
            "details": "Add Checkbox component from shadcn/ui to each item card header. Bind to form.selectedTasks, form.selectedEvents, form.selectedContacts arrays (store item IDs). Initialize all checkboxes to checked on load. Implement Select All / Deselect All toggle buttons per section. Update item card styling to show visual feedback when deselected (opacity-50, grayscale filter). Add selection summary at bottom showing 'X of Y tasks selected'. Disable Create Plan button if no items selected. Ensure checkbox state persists when switching between edit and view modes.",
            "status": "pending",
            "testStrategy": "Verify all items checked by default on load. Test individual checkbox toggles update selection state. Confirm Select All/Deselect All buttons work per section. Verify deselected items show visual feedback. Test Create Plan button disabled with zero selections."
          },
          {
            "id": 7,
            "title": "Create batch insert mutation to Convex",
            "description": "Build Convex mutation that accepts selected items array and performs transactional batch insert of tasks, events, and contacts",
            "dependencies": [
              6
            ],
            "details": "Create convex/import.ts with mutation createWorkspaceFromImport({tasks, events, contacts, workspaceId}). Use ctx.db.insert() in transaction for atomic operation. Map task objects to Convex schema: {title, description, priority, status: 'pending', workspaceId, createdAt}. Map event objects: {title, startAt, endAt, timezone, workspaceId, createdAt}. Map contact objects: {name, role, workspaceId, createdAt}. Generate unique IDs for cross-references if needed. Return summary object {taskCount, eventCount, contactCount, workspaceId}. Add error handling for schema validation failures, duplicates, and constraint violations. Implement rollback on any insert failure.",
            "status": "pending",
            "testStrategy": "Test mutation successfully inserts selected items. Verify transaction rolls back if any insert fails. Confirm return summary matches inserted counts. Test schema validation rejects invalid data. Verify duplicate detection prevents conflicts."
          },
          {
            "id": 8,
            "title": "Add loading states and error handling",
            "description": "Implement comprehensive loading indicators, error boundaries, and user feedback for all async operations in the import flow",
            "dependencies": [
              3,
              7
            ],
            "details": "Create loading state for Create Plan button using isSubmitting from TanStack Form. Show spinner overlay on preview panel during mutation execution with message 'Creating workspace...'. Implement error boundary component wrapping import route to catch React errors. Add error state handling for SSE connection failures (show retry button). Handle mutation errors by displaying toast notification with error message and keeping user on preview step. Add network error detection with offline indicator. Implement timeout handling for SSE (30s max) and mutation (10s max). Log all errors to Sentry with import context metadata.",
            "status": "pending",
            "testStrategy": "Test loading spinner shows during mutation execution. Verify error boundary catches and displays React errors. Test SSE timeout triggers retry option. Confirm mutation errors show toast and preserve form state. Verify Sentry receives error logs with context."
          },
          {
            "id": 9,
            "title": "Implement success redirect with toast notification",
            "description": "Add post-creation success handling with informative toast message and automatic redirect to tasks page",
            "dependencies": [
              7,
              8
            ],
            "details": "After successful createWorkspaceFromImport mutation, extract returned summary (taskCount, eventCount, contactCount). Use react-hot-toast or sonner to display success notification: 'Workspace created with X tasks and Y events' (green theme, 3s duration, include checkmark icon). Clear form state and sessionStorage. Use TanStack Router navigate() to redirect to /tasks route with workspaceId query param. Add 500ms delay before redirect to allow toast to be visible. Include celebration animation (confetti or checkmark) on success. Track successful import event in analytics with counts metadata.",
            "status": "pending",
            "testStrategy": "Verify toast displays with correct counts after successful creation. Confirm redirect happens to /tasks route with correct workspaceId. Test form state cleared after redirect. Verify sessionStorage cleaned up. Confirm analytics event tracked with metadata."
          }
        ]
      },
      {
        "id": 13,
        "title": "Task CRUD operations with Convex mutations and queries",
        "description": "Implement comprehensive task management with create, read, update, delete, reorder, and filter operations using Convex",
        "details": "Create convex/tasks.ts with queries: listTasks(workspaceId, filters), getTask(taskId), getTasksByStatus(workspaceId, status), and mutations: createTask(workspaceId, title, description, details, priority, dueAt, assigneeId, labels), updateTask(taskId, updates), deleteTask(taskId), reorderTasks(workspaceId, orderedIds), linkPR(taskId, prUrl). Implement optimistic updates using Convex's useOptimistic hook. Add task filtering by status, assignee, labels, due date range. Implement search with fuzzy matching on title/description using Fuse.js@7. Create task assignment logic that validates assigneeId exists in workspace members. Add cascade delete for tasks when workspace is deleted. Implement task archival instead of hard delete (add 'archived' boolean field). Create batch operations: markMultipleDone(taskIds), updateMultiple(taskIds, updates). Add sorting by createdAt, dueAt, priority, or custom order.",
        "testStrategy": "Create task and verify it appears in list queries. Test update mutations reflect immediately. Confirm delete removes task. Test reorder updates task positions. Verify filter and search return correct results. Test optimistic updates show instantly before server confirmation.",
        "priority": "high",
        "dependencies": [
          2,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create convex/tasks.ts file with base schema and type definitions",
            "description": "Set up the tasks module file structure with TypeScript types and Convex table reference for task operations",
            "dependencies": [],
            "details": "Create convex/tasks.ts file. Import necessary Convex utilities (query, mutation, v) from 'convex/server'. Define TaskFilters type with optional fields: status, assigneeId, labels, dueDateFrom, dueDateTo. Define TaskUpdate type for partial task updates. Import tasks table reference from schema. Set up file structure with sections for queries, mutations, and helper functions.",
            "status": "pending",
            "testStrategy": "Verify file compiles without TypeScript errors. Confirm Convex dev server picks up the new file without errors."
          },
          {
            "id": 2,
            "title": "Implement query functions: listTasks, getTask, getTasksByStatus",
            "description": "Create Convex query functions for retrieving tasks with filtering, single task lookup, and status-based retrieval",
            "dependencies": [
              1
            ],
            "details": "Implement listTasks query accepting workspaceId and optional filters parameter. Use ctx.db.query('tasks').withIndex('by_workspace', q => q.eq('workspaceId', workspaceId)). Apply filters for status, assigneeId, labels array matching, and due date range filtering. Implement getTask query accepting taskId, return single task or null. Implement getTasksByStatus query accepting workspaceId and status, filter tasks by status field. Add archived field filter to exclude archived tasks unless explicitly requested. Return tasks sorted by custom order field or createdAt.",
            "status": "pending",
            "testStrategy": "Test listTasks returns all non-archived tasks for workspace. Verify filters work correctly for each field. Test getTask returns correct task by ID. Verify getTasksByStatus filters accurately. Confirm archived tasks are excluded by default."
          },
          {
            "id": 3,
            "title": "Implement createTask and updateTask mutations with validation",
            "description": "Create mutations for task creation and updates with assignee validation and field constraints",
            "dependencies": [
              1
            ],
            "details": "Implement createTask mutation accepting workspaceId, title, description, details, priority, dueAt, assigneeId, labels. Validate assigneeId exists in workspace memberships using ctx.db.query('memberships').withIndex('by_workspace', q => q.eq('workspaceId', workspaceId).eq('userId', assigneeId)). Set initial status to 'pending', archived to false, createdAt to Date.now(). Generate custom order as max existing order + 1. Implement updateTask mutation accepting taskId and updates object. Validate assigneeId if provided in updates. Merge updates with existing task data. Return created/updated task ID.",
            "status": "pending",
            "testStrategy": "Test createTask creates task with all fields correctly. Verify assigneeId validation rejects non-member users. Test updateTask modifies only specified fields. Confirm validation errors thrown for invalid assigneeId."
          },
          {
            "id": 4,
            "title": "Implement deleteTask mutation with archival logic",
            "description": "Create soft delete functionality that archives tasks instead of permanently removing them",
            "dependencies": [
              1
            ],
            "details": "Implement deleteTask mutation accepting taskId. Instead of ctx.db.delete(taskId), use ctx.db.patch(taskId, { archived: true, archivedAt: Date.now() }). Add optional hard delete parameter for admin operations. Ensure archived tasks are excluded from default queries. Add restoreTask mutation to unarchive tasks by setting archived: false and removing archivedAt timestamp.",
            "status": "pending",
            "testStrategy": "Test deleteTask sets archived flag instead of removing record. Verify archived tasks don't appear in listTasks. Test hard delete option permanently removes task. Confirm restoreTask successfully unarchives tasks."
          },
          {
            "id": 5,
            "title": "Implement reorderTasks mutation with position updates",
            "description": "Create mutation to handle task reordering with custom order field updates for drag-and-drop functionality",
            "dependencies": [
              1,
              3
            ],
            "details": "Implement reorderTasks mutation accepting workspaceId and orderedIds array. Validate all taskIds belong to the workspace. Iterate through orderedIds array with index. For each taskId, update custom order field to index value using ctx.db.patch. Batch updates efficiently. Ensure order changes are transactional. Handle cases where some tasks may be missing from orderedIds.",
            "status": "pending",
            "testStrategy": "Test reorderTasks updates task order correctly. Verify listTasks returns tasks in new order. Test with partial orderedIds array. Confirm workspace validation prevents cross-workspace reordering."
          },
          {
            "id": 6,
            "title": "Implement batch operations: markMultipleDone and updateMultiple mutations",
            "description": "Create mutations for bulk task operations including status updates and field modifications",
            "dependencies": [
              1,
              3
            ],
            "details": "Implement markMultipleDone mutation accepting taskIds array. Validate all tasks exist and are accessible. Use Promise.all to batch ctx.db.patch operations updating status to 'done' and completedAt to Date.now(). Implement updateMultiple mutation accepting taskIds array and updates object. Apply same updates to all specified tasks. Validate updates don't include protected fields like workspaceId or createdAt. Return count of successfully updated tasks.",
            "status": "pending",
            "testStrategy": "Test markMultipleDone updates all specified tasks to done status. Verify updateMultiple applies changes to all tasks. Test with empty taskIds array. Confirm protected field updates are rejected. Verify partial failures don't break transaction."
          },
          {
            "id": 7,
            "title": "Implement fuzzy search with Fuse.js integration",
            "description": "Add search functionality with fuzzy matching on task titles and descriptions using Fuse.js library",
            "dependencies": [
              1,
              2
            ],
            "details": "Install fuse.js@7 package. Create searchTasks query accepting workspaceId and searchTerm. Retrieve all non-archived tasks for workspace. Initialize Fuse instance with tasks array and options: keys: ['title', 'description'], threshold: 0.4, includeScore: true. Execute search with searchTerm. Map Fuse results back to task objects. Return ranked results. Handle empty search term by returning all tasks. Add optional limit parameter to restrict result count.",
            "status": "pending",
            "testStrategy": "Test search returns relevant results for title matches. Verify description matching works. Test fuzzy matching catches typos and partial matches. Confirm empty search returns all tasks. Test ranking orders results by relevance score."
          },
          {
            "id": 8,
            "title": "Implement optimistic updates using Convex useOptimistic hook and cascade delete logic",
            "description": "Add client-side optimistic updates for immediate UI feedback and implement cascade delete for workspace removal",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create app/lib/optimistic-tasks.ts with useOptimisticTasks hook wrapping Convex useOptimistic. Implement optimistic handlers for createTask, updateTask, deleteTask, and reorderTasks that immediately update local state before server confirmation. Handle rollback on mutation failure. In convex/workspaces.ts, add onDelete trigger for workspace table. Query all tasks with workspaceId match. Batch archive all tasks using Promise.all with ctx.db.patch setting archived: true. Implement linkPR mutation accepting taskId and prUrl, updating task with prUrl field and linkedAt timestamp. Add sorting logic to queries supporting sort by createdAt, dueAt, priority, or order fields with asc/desc direction parameter.",
            "status": "pending",
            "testStrategy": "Test optimistic updates show immediate UI changes before server response. Verify rollback on mutation failure. Test cascade delete archives all workspace tasks when workspace deleted. Confirm linkPR mutation stores PR URL correctly. Test sorting options return correctly ordered results for each field."
          }
        ]
      },
      {
        "id": 14,
        "title": "Kanban board UI with drag-and-drop and real-time collaboration",
        "description": "Build interactive Kanban board with columns for Backlog, In Progress, Blocked, Done, supporting drag-and-drop reordering and live multi-user updates",
        "details": "Create app/routes/tasks.tsx with Kanban layout using CSS Grid (4 columns). Install @dnd-kit/core@latest, @dnd-kit/sortable, @dnd-kit/utilities for drag-and-drop. Create TaskCard component showing title, assignee avatar, due date, labels as colored badges, PR status chip. Use Convex useQuery() to subscribe to tasks by workspace with real-time updates. Group tasks by status into column arrays. Implement DndContext with onDragEnd handler that calls updateTask(taskId, { status: newStatus }) and optimistically updates local state. Add DragOverlay for visual feedback during drag. Implement keyboard navigation for accessibility (Arrow keys to move focus, Space/Enter to pick up/drop). Add task quick-add input at top of each column. Show task count badges on column headers. Implement column collapsing for focused view. Add filters sidebar with status toggles, assignee multi-select, label chips, date range picker. Show presence indicators (colored dots) on tasks being viewed by other users.",
        "testStrategy": "Drag task between columns and verify status updates in DB. Open two browser tabs and confirm task moves reflect in both <300ms. Test keyboard navigation moves tasks correctly. Verify quick-add creates task in correct column. Test filters update visible tasks. Confirm presence dots appear when multiple users view same task.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure @dnd-kit dependencies",
            "description": "Set up @dnd-kit/core, @dnd-kit/sortable, and @dnd-kit/utilities packages with proper TypeScript configuration",
            "dependencies": [],
            "details": "Run npm install @dnd-kit/core@latest @dnd-kit/sortable@latest @dnd-kit/utilities@latest. Create app/lib/dnd-config.ts to export shared DnD configurations including collision detection strategy (closestCenter), measuring configuration, and accessibility announcements. Set up TypeScript types for drag events and DnD context values.",
            "status": "pending",
            "testStrategy": "Verify packages are installed correctly in package.json. Import @dnd-kit components in a test file to confirm TypeScript types resolve without errors."
          },
          {
            "id": 2,
            "title": "Create CSS Grid Kanban column layout structure",
            "description": "Build responsive 4-column Kanban board layout using CSS Grid with column headers and task containers",
            "dependencies": [],
            "details": "Create app/routes/tasks.tsx with CSS Grid container (grid-template-columns: repeat(4, 1fr)). Define four columns: Backlog, In Progress, Blocked, Done. Add column headers with task count badges. Style columns with borders, background colors, min-height: 600px, and overflow-y: auto for scrollable task lists. Add responsive breakpoints for mobile (single column) and tablet (two columns).",
            "status": "pending",
            "testStrategy": "Render Kanban board and verify 4 columns display correctly on desktop. Test responsive breakpoints on mobile and tablet viewports. Confirm columns scroll independently when task lists overflow."
          },
          {
            "id": 3,
            "title": "Build TaskCard component with all visual elements",
            "description": "Create reusable TaskCard component displaying title, assignee avatar, due date, colored label badges, and PR status chip",
            "dependencies": [],
            "details": "Create app/components/TaskCard.tsx accepting task prop. Render card with title, assignee avatar (using user initials or image), due date with relative time display (e.g., 'Due in 3 days'), labels as colored badge chips, PR status chip with status-specific colors (draft/open/merged). Add hover state with subtle shadow. Include aria-label for accessibility. Style with rounded corners, padding, and border.",
            "status": "pending",
            "testStrategy": "Render TaskCard with mock task data and verify all elements display correctly. Test with missing optional fields (no assignee, no due date). Verify hover state applies correctly. Test accessibility with screen reader."
          },
          {
            "id": 4,
            "title": "Implement Convex real-time task subscription",
            "description": "Set up Convex useQuery hook to subscribe to tasks by workspace with automatic real-time updates",
            "dependencies": [
              2
            ],
            "details": "In app/routes/tasks.tsx, use const tasks = useQuery(api.tasks.listByWorkspace, { workspaceId }) to subscribe to tasks. Implement groupTasksByStatus(tasks) utility function to organize tasks into four arrays by status field. Handle loading state while query initializes. Handle null/undefined tasks gracefully. Ensure tasks automatically update when mutations occur in other sessions due to Convex reactivity.",
            "status": "pending",
            "testStrategy": "Open two browser tabs with same workspace. Create task in one tab and verify it appears in the other tab within 300ms. Delete task and confirm removal reflects in both tabs. Test with empty workspace."
          },
          {
            "id": 5,
            "title": "Implement drag-and-drop with DndContext and onDragEnd handler",
            "description": "Set up DndContext with sortable lists per column and implement onDragEnd handler to update task status with optimistic updates",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Wrap Kanban board in <DndContext onDragEnd={handleDragEnd} sensors={sensors} collisionDetection={closestCenter}>. Create useSensors hook with PointerSensor and KeyboardSensor. For each column, wrap tasks in <SortableContext items={columnTasks} strategy={verticalListSortingStrategy}>. Wrap each TaskCard in <SortableItem id={task._id}>. Implement handleDragEnd to extract taskId and new status from event.over. Call updateTask mutation with optimistic update using Convex ctx.optimisticUpdate(). Handle edge cases where drag cancelled or invalid drop target.",
            "status": "pending",
            "testStrategy": "Drag task from Backlog to In Progress and verify status updates in database. Test drag cancellation (drop outside valid zone). Verify optimistic update shows immediate UI change before server confirmation. Test race condition handling by dragging multiple tasks rapidly."
          },
          {
            "id": 6,
            "title": "Add DragOverlay for visual feedback during drag",
            "description": "Implement DragOverlay component to show task card preview while dragging for improved user experience",
            "dependencies": [
              5
            ],
            "details": "Import <DragOverlay> from @dnd-kit/core. Track active dragging task with useState(activeId). Update activeId in onDragStart and clear in onDragEnd. Render <DragOverlay>{activeId ? <TaskCard task={tasks.find(t => t._id === activeId)} isDragging /> : null}</DragOverlay>. Style dragging card with increased opacity, shadow, and slight scale transform. Ensure overlay follows cursor smoothly.",
            "status": "pending",
            "testStrategy": "Drag task and verify overlay card appears following cursor. Confirm original card shows reduced opacity during drag. Test overlay disappears on drop. Verify smooth animation and no flickering."
          },
          {
            "id": 7,
            "title": "Implement keyboard navigation for accessibility",
            "description": "Add keyboard controls (Arrow keys, Space, Enter) to navigate and move tasks between columns accessibly",
            "dependencies": [
              5
            ],
            "details": "Configure KeyboardSensor in useSensors with KeyboardCoordinateGetter for sortable lists. Implement custom keyboard navigation: Arrow Up/Down to move focus between tasks, Arrow Left/Right to move focus between columns, Space to pick up task, Arrow keys while holding to move between columns, Space/Enter to drop. Add aria-live regions to announce drag start/end. Implement focus management to maintain focus on moved task after drop. Add skip links for keyboard users.",
            "status": "pending",
            "testStrategy": "Navigate Kanban board using only keyboard. Verify arrow keys move focus correctly. Test Space key picks up task and arrow keys move it between columns. Confirm Enter drops task in new column. Test with screen reader to verify announcements."
          },
          {
            "id": 8,
            "title": "Add quick-add input at top of each column",
            "description": "Create inline task creation input at the top of each column to quickly add tasks with pre-set status",
            "dependencies": [
              2
            ],
            "details": "Add <QuickAddInput column={status} /> component at top of each column. Implement controlled input with local state. On Enter or blur, call createTask mutation with { title, status: column, workspaceId }. Clear input after successful creation. Show loading spinner during mutation. Handle empty input validation. Auto-focus input after task creation for rapid entry. Add subtle animation when new task appears in column.",
            "status": "pending",
            "testStrategy": "Type task title in Backlog quick-add and press Enter. Verify task appears in Backlog column with pending status. Test rapid task creation (multiple tasks in succession). Confirm empty input shows validation error. Test in all four columns."
          },
          {
            "id": 9,
            "title": "Build filters sidebar with status, assignee, label, and date filters",
            "description": "Create collapsible filters sidebar with multi-select for assignees, status toggles, label chips, and date range picker",
            "dependencies": [
              4
            ],
            "details": "Create app/components/FiltersSidebar.tsx with collapsible panel. Add status toggle checkboxes for each status. Implement assignee multi-select dropdown using workspace members list. Add label chips with color-coded badges (click to toggle filter). Integrate date range picker library (react-day-picker@latest) for due date filtering. Store filter state in URL search params for shareability. Apply filters to tasks array using .filter() before grouping by status. Show active filter count badge on sidebar toggle button.",
            "status": "pending",
            "testStrategy": "Toggle status filter and verify only matching tasks display. Select multiple assignees and confirm filtering works correctly. Apply label filter and verify results. Set date range and confirm tasks outside range are hidden. Verify URL updates with filter params and page reload preserves filters."
          },
          {
            "id": 10,
            "title": "Add presence indicators showing users viewing tasks",
            "description": "Implement real-time presence indicators (colored dots) on task cards to show which users are currently viewing each task",
            "dependencies": [
              3,
              4
            ],
            "details": "Create convex/presence.ts with mutations: updatePresence(taskId, userId), clearPresence(userId). Implement heartbeat mechanism: client sends updatePresence every 10s, server expires presence after 30s. Use Convex useQuery(api.presence.getTaskPresence, { taskId }) to subscribe to presence per task. Render colored dots on TaskCard for each active user (max 3 visible, show +N for overflow). Assign persistent colors to users based on userId hash. Add tooltip showing user names on hover. Implement useEffect cleanup to clear presence on unmount.",
            "status": "pending",
            "testStrategy": "Open task in two browser tabs with different users. Verify colored presence dots appear on task card in both tabs. Close one tab and confirm dot disappears within 30s. Test with multiple users and verify overflow (+N) displays correctly. Hover over dots and confirm tooltip shows usernames."
          }
        ]
      },
      {
        "id": 15,
        "title": "Task detail view with comments and presence",
        "description": "Create detailed task view with full information, commenting system, and collaborative presence indicators showing who is viewing",
        "details": "Create app/routes/tasks/$taskId.tsx using TanStack Router's params. Use Convex useQuery(api.tasks.getTask, { taskId }) for reactive task data and useQuery(api.comments.listComments, { taskId }) for comments. Display task title (editable inline), description, details, status dropdown, priority selector, assignee picker, due date picker, labels input with autocomplete, PR URL input, source import link. Implement comments section with useQuery for real-time updates. Create comment input with markdown preview using react-markdown@9. Add mutations: addComment(taskId, body), updateComment(commentId, body), deleteComment(commentId). Show author avatar, name, and timestamp for each comment. Implement presence system: on mount, call presence.heartbeat(workspaceId, taskId) every 5s. Show avatars of users currently viewing this task with tooltip showing names. Add typing indicators for comment input using presence.updateCursor(workspaceId, taskId, { typing: true }). Display 'User is typing...' indicator when presence includes typing flag.",
        "testStrategy": "Open task detail and verify all fields display correctly. Test inline editing updates task. Add comment and verify it appears in both browser tabs instantly. Test presence shows avatars of other viewers. Verify typing indicator appears when user types comment. Confirm heartbeat keeps presence active.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create task detail route with dynamic params",
            "description": "Set up the TanStack Router route file for task detail view with dynamic taskId parameter and basic layout structure",
            "dependencies": [],
            "details": "Create app/routes/tasks/$taskId.tsx using TanStack Router's file-based routing. Import useParams() from @tanstack/router to extract taskId from URL. Set up route component with proper TypeScript typing for params. Create basic layout structure with container div and sections for task header, details, and comments. Add loading state placeholder and error boundary wrapper. Ensure route is accessible from task list by configuring proper link navigation.",
            "status": "pending",
            "testStrategy": "Navigate to /tasks/123 and verify route renders without errors. Test that params.taskId is correctly extracted. Verify loading state displays initially. Test navigation from task list to detail view."
          },
          {
            "id": 2,
            "title": "Implement real-time task data fetching",
            "description": "Set up Convex queries for fetching task details with real-time updates and proper error handling",
            "dependencies": [
              1
            ],
            "details": "Import useQuery from convex/react and configure api.tasks.getTask query with taskId parameter. Handle loading and error states appropriately. Ensure query automatically re-renders on data changes due to Convex's reactive nature. Add null checks for when task is not found. Configure query to return all task fields: title, description, details, status, priority, assignee, dueDate, labels, prUrl, sourceImportUrl. Add TypeScript types for task data structure matching Convex schema.",
            "status": "pending",
            "testStrategy": "Open task detail and verify all task fields display correctly. Open same task in two browser tabs and update task in one tab - verify other tab updates automatically. Test with non-existent taskId and verify error handling."
          },
          {
            "id": 3,
            "title": "Build inline editing for all task fields",
            "description": "Create inline editing components for title, description, status, priority, assignee, due date, labels, and URL fields with immediate persistence",
            "dependencies": [
              2
            ],
            "details": "Create reusable InlineEdit component with edit/view modes toggled on click. For title: use contentEditable div with onBlur save. For description and details: use textarea with auto-resize. Status: dropdown with predefined values (pending, in-progress, done, blocked). Priority: dropdown (low, medium, high, critical). Assignee: searchable user picker component. Due date: date picker using native input type='datetime-local'. Labels: tag input with autocomplete from existing labels. PR URL and source import: simple text inputs. Each field calls corresponding Convex mutation on change: updateTask(taskId, field, value). Show saving indicator during mutation. Add optimistic updates for instant UI feedback.",
            "status": "pending",
            "testStrategy": "Click each field and verify it becomes editable. Make changes and verify they persist after blur/save. Open task in second tab and verify changes appear immediately. Test validation for invalid dates and URLs. Verify optimistic updates show changes before server confirmation."
          },
          {
            "id": 4,
            "title": "Set up real-time comments list with subscription",
            "description": "Implement comments section with Convex query for real-time comment updates and proper rendering of comment threads",
            "dependencies": [
              2
            ],
            "details": "Add useQuery(api.comments.listComments, { taskId }) to fetch all comments for current task. Create CommentsSection component that maps over comments array. For each comment, display author avatar (using user.avatarUrl or generated initials), author name, timestamp (formatted with relative time like '2 hours ago'), and comment body. Sort comments by createdAt ascending (oldest first). Handle empty state with 'No comments yet' message. Ensure query reactively updates when new comments are added via Convex subscription. Add proper TypeScript types for Comment interface including id, taskId, authorId, body, createdAt.",
            "status": "pending",
            "testStrategy": "View task with existing comments and verify they display in correct order. Add comment in another tab and verify it appears instantly in current tab. Test avatar display for users with and without profile images. Verify timestamp formatting updates correctly."
          },
          {
            "id": 5,
            "title": "Create comment CRUD mutations and input UI",
            "description": "Build comment input component with markdown preview and wire up Convex mutations for adding, updating, and deleting comments",
            "dependencies": [
              4
            ],
            "details": "Install react-markdown@9 and remark-gfm for markdown rendering. Create CommentInput component with textarea and 'Preview' tab toggle. Implement useMutation(api.comments.addComment) with parameters { taskId, body }. Add Send button that calls mutation and clears input on success. For existing comments, add Edit and Delete buttons visible only to comment author. Implement useMutation(api.comments.updateComment) with { commentId, body } and useMutation(api.comments.deleteComment) with { commentId }. Show markdown preview using ReactMarkdown component with remark-gfm plugin for GitHub-flavored markdown (tables, strikethrough, task lists). Add optimistic updates to show comment immediately before server confirmation. Implement edit mode that replaces comment body with textarea pre-filled with existing content.",
            "status": "pending",
            "testStrategy": "Type markdown in comment input and verify preview renders correctly with formatting, links, and code blocks. Submit comment and verify it appears in list immediately. Edit own comment and verify changes persist. Delete comment and verify it's removed from list. Test that edit/delete buttons only appear for own comments."
          },
          {
            "id": 6,
            "title": "Implement presence heartbeat system",
            "description": "Set up presence tracking to show which users are currently viewing the task with periodic heartbeat updates",
            "dependencies": [
              2
            ],
            "details": "Create usePresence hook that calls api.presence.heartbeat(workspaceId, taskId) on component mount. Use setInterval to send heartbeat every 5 seconds (5000ms). Clean up interval with clearInterval in useEffect cleanup function. Implement useQuery(api.presence.listPresence, { workspaceId, taskId }) to fetch list of current viewers. Handle heartbeat expiration on backend (users not sending heartbeat for >10s are removed from presence list). Store user metadata in presence including userId, userName, avatarUrl, lastSeenAt. Ensure heartbeat includes current timestamp. Add error handling for failed heartbeat calls with exponential backoff retry logic.",
            "status": "pending",
            "testStrategy": "Open task in browser tab and verify heartbeat is sent every 5 seconds in network tab. Close tab and verify user is removed from presence list after 10 seconds. Open task in multiple tabs/browsers and verify all viewers appear in presence list."
          },
          {
            "id": 7,
            "title": "Display user avatars for current viewers",
            "description": "Create UI component showing avatars of all users currently viewing the task with tooltips displaying their names",
            "dependencies": [
              6
            ],
            "details": "Create PresenceAvatars component that receives presence list from useQuery. Map over presence data to render circular avatar images using user.avatarUrl or generated initials with distinct background colors based on userId hash. Stack avatars horizontally with slight overlap (margin-left: -8px). Limit display to first 5 avatars, show '+N' badge if more viewers present. Wrap each avatar in tooltip component showing full user name and 'viewing now' status. Add subtle pulse animation to avatars to indicate live presence. Position avatar stack in top-right corner of task detail header. Use CSS to make avatars responsive and accessible with proper alt text.",
            "status": "pending",
            "testStrategy": "Open task in one tab and verify own avatar appears. Open in second browser/user account and verify both avatars display. Hover over avatar and verify tooltip shows correct username. Test with 6+ concurrent viewers and verify overflow badge shows correct count. Close tab and verify avatar disappears within 10 seconds."
          },
          {
            "id": 8,
            "title": "Add typing indicators for comment input",
            "description": "Implement real-time typing indicators showing when other users are composing comments using presence cursor updates",
            "dependencies": [
              5,
              6
            ],
            "details": "In CommentInput component, add onChange handler that calls api.presence.updateCursor(workspaceId, taskId, { typing: true }) when user starts typing. Debounce typing indicator to avoid excessive API calls (trigger only if user has been typing for >500ms). Call updateCursor with { typing: false } when input loses focus or after 3 seconds of inactivity. Use useQuery(api.presence.listPresence) and filter for users with typing: true flag. Create TypingIndicator component that displays 'UserName is typing...' message with animated ellipsis (...). Show indicator below comment input area. Support multiple simultaneous typers with 'UserA and UserB are typing...' format. Add CSS animation for pulsing ellipsis effect.",
            "status": "pending",
            "testStrategy": "Open task in two browser tabs with different users. Start typing comment in one tab and verify 'User is typing...' indicator appears in other tab within 1 second. Stop typing and verify indicator disappears after 3 seconds. Test with multiple users typing simultaneously and verify all names appear in indicator message."
          },
          {
            "id": 9,
            "title": "Integration testing and polish for task detail view",
            "description": "Perform end-to-end testing of all task detail features, fix edge cases, and add final UI polish with loading states and animations",
            "dependencies": [
              3,
              7,
              8
            ],
            "details": "Test complete flow: navigate to task detail, verify all data loads correctly, test inline editing of every field, add/edit/delete comments with markdown, verify presence avatars and typing indicators work across multiple browser tabs. Add skeleton loading states for task data and comments while queries are loading. Implement smooth transitions for inline edit mode activation. Add confirmation dialog for destructive actions (delete comment). Test error scenarios: network failures, invalid task IDs, permission errors. Verify accessibility: keyboard navigation for all interactive elements, proper ARIA labels, screen reader compatibility. Add responsive design for mobile viewports. Optimize rendering performance with React.memo for comment list items. Test with large comment threads (100+ comments) and ensure smooth scrolling and pagination if needed.",
            "status": "pending",
            "testStrategy": "Run complete user journey test: open task, edit multiple fields simultaneously, add comments, verify all changes persist. Test with poor network conditions and verify graceful degradation. Use screen reader to verify accessibility compliance. Test on mobile device and verify responsive layout. Load task with 100+ comments and verify performance remains acceptable."
          }
        ]
      },
      {
        "id": 16,
        "title": "Calendar view with week/month display and event management",
        "description": "Build calendar interface displaying events in week and month views with navigation and event creation capabilities",
        "details": "Install react-big-calendar@latest and date-fns@latest. Create app/routes/calendar.tsx with calendar component. Use Convex useQuery(api.events.listEvents, { workspaceId }) for reactive events. Configure BigCalendar with views: ['week', 'month'], defaultView: 'week', localizer using dateFnsLocalizer with startOfWeek, format, parse from date-fns. Map Convex events to BigCalendar format: { title, start: new Date(startAt), end: new Date(endAt), resource: eventId }. Implement onSelectSlot to open 'New Event' dialog with start/end pre-filled. Create EventDialog component with form: title input, start datetime picker, end datetime picker, URL input, description textarea. Add mutations: createEvent(workspaceId, title, startAt, endAt, url, source='manual'), updateEvent(eventId, updates), deleteEvent(eventId). Implement onSelectEvent to open edit dialog. Add timezone selector defaulting to user's local TZ with Intl.DateTimeFormat().resolvedOptions().timeZone. Show PT time for hackathon-imported events alongside user's TZ. Color-code events by source: import=blue, manual=green.",
        "testStrategy": "Navigate between week and month views. Create event and verify it appears on correct dates. Test event editing updates display. Confirm timezone display shows both PT and user TZ. Verify real-time updates when event added in another tab. Test drag-to-create event in week view.",
        "priority": "high",
        "dependencies": [
          2,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure react-big-calendar with date-fns localizer",
            "description": "Set up react-big-calendar library with date-fns integration for calendar rendering and date manipulation",
            "dependencies": [],
            "details": "Install react-big-calendar@latest and date-fns@latest via npm/yarn. Import Calendar from react-big-calendar and CSS styles. Create dateFnsLocalizer using startOfWeek, format, parse, and getDay from date-fns. Configure localizer with locale settings. Set up basic Calendar component structure in app/routes/calendar.tsx with localizer prop.",
            "status": "pending",
            "testStrategy": "Verify calendar renders with correct week start day. Test date formatting displays correctly. Confirm month and week views render without errors."
          },
          {
            "id": 2,
            "title": "Implement event data fetching and mapping to calendar format",
            "description": "Connect Convex backend to fetch workspace events and transform them into react-big-calendar compatible format",
            "dependencies": [
              1
            ],
            "details": "Use Convex useQuery(api.events.listEvents, { workspaceId }) to fetch events reactively. Map Convex event objects to BigCalendar format: { title, start: new Date(startAt), end: new Date(endAt), resource: eventId }. Handle null/undefined dates gracefully. Implement loading and error states for query. Ensure event data updates trigger calendar re-render.",
            "status": "pending",
            "testStrategy": "Verify events appear on calendar after fetch. Test calendar updates when events change in Convex. Confirm date conversion handles various timestamp formats. Test loading state displays during fetch."
          },
          {
            "id": 3,
            "title": "Configure week and month view settings with navigation",
            "description": "Set up calendar views configuration and implement view switching and date navigation controls",
            "dependencies": [
              1
            ],
            "details": "Configure BigCalendar with views: ['week', 'month'], defaultView: 'week'. Implement onNavigate callback to handle date changes. Add onView callback for view switching. Create custom toolbar with view buttons and navigation arrows. Set up date range display showing current week/month. Configure week start day and time slots for week view.",
            "status": "pending",
            "testStrategy": "Navigate between week and month views and verify correct rendering. Test navigation arrows move dates correctly. Confirm current date highlighting works. Verify week view shows appropriate time slots."
          },
          {
            "id": 4,
            "title": "Create event creation dialog with datetime pickers and form validation",
            "description": "Build EventDialog component with form fields for creating new events from calendar slot selection",
            "dependencies": [
              2
            ],
            "details": "Create EventDialog component with controlled form: title input (required), start datetime picker, end datetime picker, URL input (optional), description textarea. Implement onSelectSlot callback to capture selected time range and open dialog with pre-filled start/end times. Add form validation: title non-empty, end after start, URL format validation. Create Convex mutation createEvent(workspaceId, title, startAt, endAt, url, source='manual'). Wire form submit to mutation and close dialog on success.",
            "status": "pending",
            "testStrategy": "Click calendar slot and verify dialog opens with correct start/end times. Test form validation rejects invalid inputs. Submit form and confirm event appears on calendar. Test dialog cancel/close functionality."
          },
          {
            "id": 5,
            "title": "Implement event editing and deletion functionality",
            "description": "Add event edit dialog triggered by clicking existing events with update and delete mutations",
            "dependencies": [
              4
            ],
            "details": "Implement onSelectEvent callback to open EventDialog in edit mode with event data pre-populated. Add eventId prop to EventDialog to distinguish create vs edit mode. Create Convex mutations: updateEvent(eventId, { title, startAt, endAt, url, description }), deleteEvent(eventId). Add delete button to edit dialog with confirmation prompt. Wire update form submit to updateEvent mutation. Implement optimistic updates for immediate UI feedback.",
            "status": "pending",
            "testStrategy": "Click event and verify edit dialog opens with correct data. Update event fields and confirm changes persist. Test delete button removes event from calendar. Verify confirmation prompt prevents accidental deletion."
          },
          {
            "id": 6,
            "title": "Add timezone selector and multi-timezone display logic",
            "description": "Implement timezone selection and display hackathon events in both PT and user's local timezone",
            "dependencies": [
              2
            ],
            "details": "Add timezone selector dropdown defaulting to Intl.DateTimeFormat().resolvedOptions().timeZone. Store selected timezone in component state or user preferences. For hackathon-imported events (source='import'), display dual times: original PT time and converted user timezone. Use date-fns-tz for timezone conversions. Add timezone labels to event tooltips showing 'Event Time (PT)' and 'Your Time (TZ)'. Ensure datetime pickers use selected timezone.",
            "status": "pending",
            "testStrategy": "Change timezone selector and verify event times update. Test imported events show both PT and local times. Confirm timezone conversion accuracy across DST boundaries. Verify event creation uses selected timezone."
          },
          {
            "id": 7,
            "title": "Implement event color-coding by source type",
            "description": "Apply visual differentiation to events based on their source with custom event styling",
            "dependencies": [
              2
            ],
            "details": "Create eventStyleGetter function for BigCalendar that checks event.source field. Return style objects: import events get blue background (#3b82f6), manual events get green background (#10b981). Add border and text color for accessibility. Implement custom Event component to display source badge. Configure BigCalendar with eventPropGetter prop using eventStyleGetter. Add legend/key showing color meanings.",
            "status": "pending",
            "testStrategy": "Verify imported events display with blue styling. Confirm manually created events show green. Test color contrast meets accessibility standards. Verify legend displays correct color mappings."
          },
          {
            "id": 8,
            "title": "Set up real-time event updates and calendar state persistence",
            "description": "Ensure calendar reactively updates when events change and maintains view state during updates",
            "dependencies": [
              2,
              3
            ],
            "details": "Leverage Convex useQuery reactive subscriptions to automatically re-render calendar on event changes. Implement state management to preserve current view (week/month), selected date, and scroll position during re-renders. Use React.memo or useMemo to prevent unnecessary calendar re-initializations. Test real-time updates by creating/editing events in separate browser tab. Add loading indicators for mutation states without disrupting calendar view.",
            "status": "pending",
            "testStrategy": "Open calendar in two tabs, create event in one, verify it appears in other without refresh. Test view and date selection persist during updates. Confirm scroll position maintained on event changes. Verify no flickering during real-time updates."
          }
        ]
      },
      {
        "id": 17,
        "title": "ICS calendar feed generation and subscription",
        "description": "Implement ICS file generation endpoint allowing users to subscribe to workspace calendar in external apps like Google Calendar",
        "details": "Install ics@latest library. Create app/routes/calendar/$workspaceId.ics.ts server function. Query all events for workspace. Generate ICS format using ics.createEvents() with array of events: { title, start: [year, month, day, hour, minute], end: [...], url, description, status: 'CONFIRMED', organizer: { name: workspace.name }, uid: eventId }. Set PRODID to '-//HackPack//Calendar//EN', VERSION to '2.0'. Add VTIMEZONE component for PT timezone. Return response with headers: Content-Type: 'text/calendar; charset=utf-8', Content-Disposition: 'attachment; filename=\"hackpack-calendar.ics\"', Cache-Control: 'public, max-age=60'. Add ETag header using hash of events updatedAt timestamps. Implement conditional GET with If-None-Match returning 304 when not modified. Create 'Subscribe' button on calendar page that opens /calendar/{workspaceId}.ics in new tab. Show instructions for adding to Google Calendar, Apple Calendar, Outlook.",
        "testStrategy": "Download ICS file and verify it opens in calendar app. Test subscription URL updates calendar when events change. Verify timezone handling shows events at correct times. Test caching with ETag returns 304 on unchanged calendar. Confirm all event fields populate correctly.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure ics library for event formatting",
            "description": "Install the ics@latest library and create utility functions for formatting Convex events into ICS-compatible event objects with proper date/time arrays",
            "dependencies": [],
            "details": "Run `npm install ics@latest` to add the library. Create app/lib/ics-formatter.ts with a function formatEventForICS(event) that transforms Convex event objects into ICS format: { title, start: [year, month, day, hour, minute], end: [year, month, day, hour, minute], url, description, status: 'CONFIRMED', organizer: { name: workspace.name }, uid: eventId }. Handle date conversion from ISO strings to array format required by ics library. Include error handling for invalid dates.",
            "status": "pending",
            "testStrategy": "Unit test formatEventForICS with sample Convex events. Verify start/end arrays have correct [year, month, day, hour, minute] format. Test edge cases like all-day events and events crossing midnight."
          },
          {
            "id": 2,
            "title": "Create ICS calendar feed endpoint with proper headers",
            "description": "Implement the calendar feed route at app/routes/calendar/$workspaceId.ics.ts that queries workspace events and returns ICS file with correct Content-Type and Content-Disposition headers",
            "dependencies": [
              1
            ],
            "details": "Create app/routes/calendar/$workspaceId.ics.ts server function. Extract workspaceId from params. Query all events using Convex api.events.listEvents({ workspaceId }). Map events using formatEventForICS utility. Call ics.createEvents() with events array and config: { productId: '-//HackPack//Calendar//EN', version: '2.0' }. Return Response with headers: 'Content-Type': 'text/calendar; charset=utf-8', 'Content-Disposition': 'attachment; filename=\"hackpack-calendar.ics\"', 'Cache-Control': 'public, max-age=60'. Handle errors if workspace not found or no events exist.",
            "status": "pending",
            "testStrategy": "Make GET request to /calendar/{workspaceId}.ics and verify response headers match specification. Download file and verify it's valid ICS format. Test with workspace containing 0 events and workspace with multiple events."
          },
          {
            "id": 3,
            "title": "Add VTIMEZONE component for Pacific Time timezone",
            "description": "Implement Pacific Time timezone component in the ICS output to ensure events display at correct times across different calendar applications",
            "dependencies": [
              2
            ],
            "details": "Create app/lib/vtimezone.ts with getPacificTimezone() function that returns VTIMEZONE string for America/Los_Angeles including STANDARD and DAYLIGHT components with TZOFFSETFROM, TZOFFSETTO, DTSTART, and RRULE properties. Integrate timezone component into ICS generation by manually constructing VCALENDAR structure instead of relying solely on ics.createEvents(). Insert VTIMEZONE block after BEGIN:VCALENDAR and before VEVENT components. Ensure all event DTSTART/DTEND use TZID:America/Los_Angeles parameter.",
            "status": "pending",
            "testStrategy": "Parse generated ICS file and verify VTIMEZONE component is present with correct TZID. Import into Google Calendar and Apple Calendar, confirm events show at correct PT times. Test with events during DST transition dates."
          },
          {
            "id": 4,
            "title": "Implement ETag generation for calendar caching",
            "description": "Generate ETag header based on hash of events updatedAt timestamps to enable efficient caching and reduce server load",
            "dependencies": [
              2
            ],
            "details": "Install crypto module (built-in Node.js). Create app/lib/etag.ts with generateCalendarETag(events) function. Extract all updatedAt timestamps from events array, sort them, concatenate into string, and generate SHA-256 hash using crypto.createHash('sha256').update(timestamps).digest('hex'). In calendar endpoint, generate ETag after querying events and before creating ICS. Add ETag header to response: 'ETag': `\"${etag}\"` (quoted per HTTP spec). Store ETag generation in try-catch to handle edge cases.",
            "status": "pending",
            "testStrategy": "Request calendar feed twice with same events, verify ETag matches. Modify event updatedAt, verify ETag changes. Test ETag format matches HTTP spec with quotes. Verify hash is consistent for same input data."
          },
          {
            "id": 5,
            "title": "Implement conditional GET with If-None-Match and 304 responses",
            "description": "Add conditional GET support that checks If-None-Match header against current ETag and returns 304 Not Modified when calendar hasn't changed",
            "dependencies": [
              4
            ],
            "details": "In app/routes/calendar/$workspaceId.ics.ts, extract If-None-Match header from request. After generating current ETag but before creating ICS content, compare request If-None-Match with current ETag (strip quotes if present). If ETags match, return new Response(null, { status: 304, headers: { 'ETag': currentETag } }). If ETags don't match or header not present, proceed with full ICS generation. Add cache validation logging for debugging. Handle multiple ETags in If-None-Match (comma-separated list).",
            "status": "pending",
            "testStrategy": "Request calendar, save ETag. Request again with If-None-Match header matching ETag, verify 304 response with empty body. Modify event, request with old ETag, verify 200 response with new content. Test with invalid ETag returns 200."
          },
          {
            "id": 6,
            "title": "Create subscribe button UI with calendar app instructions",
            "description": "Add subscribe button to calendar page that opens ICS feed URL and displays modal with subscription instructions for Google Calendar, Apple Calendar, and Outlook",
            "dependencies": [
              5
            ],
            "details": "In app/routes/calendar.tsx, add 'Subscribe' button in calendar header using Button component. On click, open `/calendar/${workspaceId}.ics` in new tab using window.open(). Create SubscribeModal component with tabs for Google Calendar (instructions: 'Copy URL, go to Google Calendar > Settings > Add calendar > From URL'), Apple Calendar ('File > New Calendar Subscription, paste URL'), and Outlook ('Add calendar > Subscribe from web, paste URL'). Include copy-to-clipboard button for feed URL. Show modal after subscribe button clicked using useState modal visibility toggle.",
            "status": "pending",
            "testStrategy": "Click subscribe button, verify new tab opens with ICS file download. Verify modal displays with all three calendar platform instructions. Test copy-to-clipboard functionality. Verify URL in instructions matches actual feed endpoint."
          },
          {
            "id": 7,
            "title": "Test calendar feed with multiple calendar applications",
            "description": "Comprehensive testing of ICS feed subscription and updates across Google Calendar, Apple Calendar, and Outlook to verify compatibility and real-time sync",
            "dependencies": [
              6
            ],
            "details": "Create test workspace with 5+ events spanning different dates and times. Subscribe to calendar feed in Google Calendar using 'Add calendar from URL' feature. Verify all events appear with correct titles, times (in PT), and descriptions. Test in Apple Calendar app on macOS/iOS by subscribing to feed URL. Test in Outlook web/desktop by adding internet calendar. Create new event in HackPack, wait for cache expiry (60s), verify calendar apps refresh and show new event. Test event updates and deletions propagate. Document any compatibility issues or required workarounds.",
            "status": "pending",
            "testStrategy": "Subscribe in all three platforms, verify initial sync shows all events. Add event in HackPack, wait 60s, force refresh in calendar apps, confirm new event appears. Update event time, verify change reflects. Delete event, confirm removal. Test timezone display matches PT across platforms."
          }
        ]
      },
      {
        "id": 18,
        "title": "GitHub webhook handler for PR and CodeRabbit events",
        "description": "Implement webhook endpoint to receive GitHub PR events and CodeRabbit check run updates for automated task gating",
        "details": "Create app/routes/webhooks/github.ts POST handler. Verify webhook signature using GITHUB_WEBHOOK_SECRET and crypto.createHmac('sha256', secret). Parse event type from X-GitHub-Event header. Handle events: 'pull_request' (opened, synchronized, closed) and 'check_run' (completed). For pull_request events: extract PR URL, find tasks with matching prUrl using Convex query, update task metadata with PR state (open/draft/merged). For check_run events: filter for check_run.app.name === 'CodeRabbit' or check_run.name.includes('coderabbit'), extract conclusion (success/failure/neutral), map to prStatus (approved/changes_requested/pending). Update all tasks with matching prUrl. If approved and task status is 'blocked', auto-update to 'in_progress'. Log all webhook events to Sentry for debugging. Return 200 OK for successful processing, 401 for signature mismatch, 500 for processing errors. Implement idempotency using check_run.id or pull_request.id to prevent duplicate processing.",
        "testStrategy": "Send test webhook payload from GitHub and verify handler processes correctly. Test signature validation rejects invalid signatures. Confirm PR status updates task metadata. Verify CodeRabbit approval changes task prStatus to 'approved'. Test auto-unblock when approved. Confirm Sentry logs webhook events.",
        "priority": "high",
        "dependencies": [
          3,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create webhook endpoint with signature verification",
            "description": "Set up app/routes/webhooks/github.ts POST route with GitHub webhook signature validation using HMAC SHA-256",
            "dependencies": [],
            "details": "Create app/routes/webhooks/github.ts file with POST handler. Retrieve GITHUB_WEBHOOK_SECRET from environment variables. Extract X-Hub-Signature-256 header from incoming request. Read raw request body and compute HMAC SHA-256 hash using crypto.createHmac('sha256', secret).update(body).digest('hex'). Compare computed signature with header value using constant-time comparison. Return 401 Unauthorized if signatures don't match. Parse request body as JSON only after successful verification. Extract X-GitHub-Event header for event type routing.",
            "status": "pending",
            "testStrategy": "Send webhook with valid signature and verify 200 response. Send webhook with invalid/missing signature and confirm 401 rejection. Test with malformed JSON body. Verify constant-time comparison prevents timing attacks."
          },
          {
            "id": 2,
            "title": "Implement pull_request event handling",
            "description": "Parse pull_request webhook events (opened, synchronized, closed) and extract PR metadata for task updates",
            "dependencies": [
              1
            ],
            "details": "Check X-GitHub-Event header equals 'pull_request'. Filter for action types: opened, synchronize, reopened, closed. Extract PR URL from pull_request.html_url field. Extract PR state: pull_request.state (open/closed), pull_request.draft boolean. Map to internal prState values (open/draft/merged) based on state and merged_at fields. Store extracted data for task lookup in next step. Handle edge cases like pull_request object missing required fields with appropriate error logging.",
            "status": "pending",
            "testStrategy": "Send pull_request webhook with action=opened and verify PR URL extraction. Test with draft PR and confirm draft state detection. Send closed event with merged=true and verify merged state. Test with missing fields and confirm error handling."
          },
          {
            "id": 3,
            "title": "Implement check_run event handling for CodeRabbit",
            "description": "Parse check_run webhook events specifically for CodeRabbit reviews and extract approval status",
            "dependencies": [
              1
            ],
            "details": "Check X-GitHub-Event header equals 'check_run'. Filter for action='completed' only. Verify check_run.app.name === 'CodeRabbit' OR check_run.name.toLowerCase().includes('coderabbit'). Extract check_run.conclusion field (success, failure, neutral, cancelled, skipped, timed_out, action_required). Map conclusion to prStatus: success → 'approved', failure/action_required → 'changes_requested', neutral/cancelled/skipped → 'pending'. Extract pull_requests array from check_run to get associated PR URLs. Store check_run.id for idempotency tracking.",
            "status": "pending",
            "testStrategy": "Send check_run webhook with CodeRabbit app and conclusion=success, verify prStatus maps to approved. Test with conclusion=failure and confirm changes_requested mapping. Send check_run from different app and verify it's ignored. Test with missing pull_requests array."
          },
          {
            "id": 4,
            "title": "Implement task lookup and status updates via Convex",
            "description": "Query Convex for tasks matching PR URL and update task metadata with PR state and CodeRabbit status",
            "dependencies": [
              2,
              3
            ],
            "details": "Create Convex query to find tasks where prUrl matches extracted PR URL. For pull_request events: update task metadata fields prState (open/draft/merged) using Convex mutation. For check_run events: update prStatus field (approved/changes_requested/pending) on all matching tasks. Handle multiple tasks with same prUrl by iterating and updating each. Wrap Convex calls in try-catch with proper error handling. Return count of updated tasks for logging. Ensure atomic updates to prevent race conditions.",
            "status": "pending",
            "testStrategy": "Link task to PR URL, send pull_request webhook and verify task prState updates. Send check_run webhook and confirm prStatus field changes. Test with multiple tasks sharing same PR URL and verify all update. Test Convex connection failure and confirm error handling."
          },
          {
            "id": 5,
            "title": "Implement auto-unblock logic for approved PRs",
            "description": "Automatically transition tasks from blocked to in_progress status when CodeRabbit approves the PR",
            "dependencies": [
              4
            ],
            "details": "After updating prStatus to 'approved' from check_run event, check current task status field. If task.status === 'blocked', call Convex mutation to update task.status to 'in_progress'. Log status transition with task ID, old status, new status, and trigger reason (CodeRabbit approval). Only auto-transition 'blocked' tasks, leave other statuses unchanged. Include timestamp in task metadata for audit trail. Handle edge case where task was manually updated between query and mutation.",
            "status": "pending",
            "testStrategy": "Create blocked task with linked PR. Send CodeRabbit approval webhook and verify task transitions to in_progress. Test with task in pending status and confirm no transition occurs. Verify audit trail metadata includes timestamp and reason. Test concurrent updates during transition."
          },
          {
            "id": 6,
            "title": "Implement idempotency using event IDs",
            "description": "Prevent duplicate processing of webhook events by tracking processed event IDs in Convex",
            "dependencies": [
              1
            ],
            "details": "Create Convex table 'processedWebhookEvents' with fields: eventId (string, indexed), eventType (string), processedAt (number). Extract unique event ID: for pull_request use pull_request.id, for check_run use check_run.id. Before processing, query Convex to check if eventId exists. If exists, return 200 OK immediately with 'already processed' message. If new, insert eventId record, then proceed with event processing. Implement TTL or cleanup strategy to prevent unbounded table growth (e.g., delete records older than 30 days). Handle race conditions with unique index constraint.",
            "status": "pending",
            "testStrategy": "Send same webhook payload twice and verify second request returns immediately without duplicate processing. Check Convex table contains single entry. Test concurrent identical webhooks and confirm only one processes. Verify cleanup removes old entries after TTL period."
          },
          {
            "id": 7,
            "title": "Add error handling and Sentry logging",
            "description": "Implement comprehensive error handling with Sentry integration for webhook processing failures and debugging",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Wrap entire webhook handler in try-catch block. Log all incoming webhooks to Sentry with event type, action, and sender info using Sentry.addBreadcrumb(). For errors, capture to Sentry with full context: event payload (sanitized), signature validation result, parsing errors, Convex failures. Return 500 status with generic error message, log detailed error to Sentry only. Implement Sentry tags: webhook_event_type, webhook_action, has_matching_tasks. Add performance monitoring for webhook processing duration. Sanitize sensitive data (tokens, secrets) before logging. Include request ID for correlation.",
            "status": "pending",
            "testStrategy": "Trigger signature validation failure and verify Sentry captures error with correct tags. Send malformed JSON and confirm parsing error logged. Simulate Convex failure and check Sentry includes full context. Verify sensitive data is sanitized in logs. Test performance monitoring tracks duration."
          },
          {
            "id": 8,
            "title": "Create webhook event replay testing infrastructure",
            "description": "Build tooling to replay webhook events for testing and debugging webhook handler behavior",
            "dependencies": [
              7
            ],
            "details": "Create test/webhooks/replay.ts script that reads sample webhook payloads from test/fixtures/github-webhooks/. Include fixtures: pull_request_opened.json, pull_request_closed_merged.json, check_run_coderabbit_success.json, check_run_coderabbit_failure.json. Script should compute valid HMAC signature using test GITHUB_WEBHOOK_SECRET, set proper headers (X-GitHub-Event, X-Hub-Signature-256), POST to local webhook endpoint. Add npm script 'test:webhook-replay' to package.json. Document usage in README with examples. Implement optional --watch mode for rapid iteration during development.",
            "status": "pending",
            "testStrategy": "Run replay script with pull_request fixture and verify handler processes correctly. Test with check_run fixture and confirm CodeRabbit status updates. Verify computed signatures pass validation. Test all fixture files successfully replay. Confirm watch mode detects fixture changes and reruns."
          }
        ]
      },
      {
        "id": 19,
        "title": "Dev workflow page showing GitHub PRs and CodeRabbit status",
        "description": "Build developer workflow page listing workspace PRs with CodeRabbit review status and task linking capabilities",
        "details": "Create app/routes/dev.tsx displaying list of tasks with prUrl field. For each task with prUrl, show card with task title, PR link (external icon), PR state badge (Open/Draft/Merged), CodeRabbit status chip (Pending=yellow, Changes Requested=red, Approved=green, Not Started=gray). Implement 'Link PR' action on tasks: open dialog with PR URL input, validate GitHub URL format (https://github.com/owner/repo/pull/number), call linkPR mutation. Add 'Refresh Status' button that triggers manual GitHub API polling: GET /repos/:owner/:repo/pulls/:number and GET /repos/:owner/:repo/commits/:sha/check-runs?check_name=CodeRabbit. Parse response and update task prStatus. Show last updated timestamp. Implement task completion gating: if prStatus !== 'approved', show lock icon and tooltip 'Blocked until CodeRabbit approves'. Disable 'Mark Done' button until approved. Add filter to show only PR-linked tasks. Show count of pending reviews at top.",
        "testStrategy": "Link PR to task and verify it appears on dev page. Test status chip shows correct CodeRabbit state. Confirm 'Mark Done' is disabled when not approved. Trigger webhook to approve PR and verify chip updates to green and task unlocks within 10s. Test manual refresh updates status. Verify linking validates GitHub URL format.",
        "priority": "high",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create dev.tsx route with PR list UI structure",
            "description": "Build the main dev workflow page route that displays tasks with linked PRs in a card-based layout",
            "dependencies": [],
            "details": "Create app/routes/dev.tsx as a new route file. Query all tasks from Convex filtering for tasks where prUrl field exists. Render a grid/list of cards, each showing task title, prUrl as clickable external link with icon, and placeholder areas for status badges and chips. Include header with page title 'Developer Workflow' and total count of PR-linked tasks. Add empty state message when no tasks have PRs linked. Use Tailwind CSS for responsive card layout.",
            "status": "pending",
            "testStrategy": "Navigate to /dev route and verify page renders. Confirm tasks with prUrl appear in list. Test external link opens GitHub PR in new tab. Verify count displays correctly. Test responsive layout on mobile and desktop."
          },
          {
            "id": 2,
            "title": "Implement Link PR dialog with URL validation",
            "description": "Create dialog component for linking GitHub PR URLs to tasks with format validation",
            "dependencies": [
              1
            ],
            "details": "Build LinkPRDialog component using shadcn/ui Dialog. Add button on each task card labeled 'Link PR'. Dialog contains text input for PR URL with label 'GitHub Pull Request URL'. Implement validation regex pattern: ^https://github\\.com/[^/]+/[^/]+/pull/\\d+$ to ensure correct GitHub PR URL format. Show validation error message if format invalid. On valid submit, call Convex mutation tasks.linkPR(taskId, prUrl). Close dialog on success. Show loading state during mutation. Handle errors with toast notification.",
            "status": "pending",
            "testStrategy": "Click 'Link PR' button and verify dialog opens. Test invalid URLs show validation error. Test valid GitHub PR URL accepts and calls mutation. Verify task updates with prUrl after successful link. Confirm error handling shows appropriate message."
          },
          {
            "id": 3,
            "title": "Build PR state badge component with color coding",
            "description": "Create reusable badge component displaying GitHub PR state (Open/Draft/Merged) with appropriate styling",
            "dependencies": [
              1
            ],
            "details": "Create components/PRStateBadge.tsx accepting prState prop ('open' | 'draft' | 'merged' | null). Render Badge component with conditional styling: Open=blue background, Draft=yellow background, Merged=purple background. Display capitalized state text. Default to gray 'Unknown' if prState is null or undefined. Extract prState from task metadata updated by webhook handler. Position badge next to PR link in task card.",
            "status": "pending",
            "testStrategy": "Render badge with different prState values and verify correct colors appear. Test 'open' shows blue, 'draft' shows yellow, 'merged' shows purple. Verify unknown state shows gray. Confirm badge displays correctly in task card layout."
          },
          {
            "id": 4,
            "title": "Create CodeRabbit status chip with conditional colors",
            "description": "Build status chip component showing CodeRabbit review state with color-coded indicators",
            "dependencies": [
              1
            ],
            "details": "Create components/CodeRabbitChip.tsx accepting prStatus prop ('pending' | 'changes_requested' | 'approved' | 'not_started' | null). Render Chip/Badge with conditional colors: Pending=yellow, Changes Requested=red, Approved=green, Not Started=gray. Display human-readable text ('Pending Review', 'Changes Requested', 'Approved', 'Not Started'). Extract prStatus from task metadata. Position chip prominently on task card below PR link and state badge. Add small CodeRabbit icon if available.",
            "status": "pending",
            "testStrategy": "Render chip with each prStatus value and verify correct colors. Test 'pending' shows yellow, 'changes_requested' shows red, 'approved' shows green. Verify text displays correctly. Confirm chip positioning in task card is visible and clear."
          },
          {
            "id": 5,
            "title": "Implement manual refresh functionality using GitHub API",
            "description": "Add refresh button that polls GitHub API to fetch latest PR state and CodeRabbit check run status",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Add 'Refresh Status' button on each task card with PR linked. Create Convex action tasks.refreshPRStatus(taskId) that extracts owner, repo, prNumber from task.prUrl. Use GITHUB_API_TOKEN from environment to call GitHub REST API: GET /repos/:owner/:repo/pulls/:number for PR state, and GET /repos/:owner/:repo/commits/:sha/check-runs?check_name=CodeRabbit for check run status. Parse responses to determine prState and prStatus. Update task metadata with new values and current timestamp as lastUpdated. Show loading spinner during refresh. Display lastUpdated timestamp below chip as 'Updated 5m ago' using relative time formatting.",
            "status": "pending",
            "testStrategy": "Click 'Refresh Status' button and verify GitHub API calls execute. Confirm prState and prStatus update in task metadata. Test lastUpdated timestamp displays and updates. Verify loading spinner appears during request. Test error handling if API call fails."
          },
          {
            "id": 6,
            "title": "Implement task completion gating logic",
            "description": "Add business logic to prevent task completion unless CodeRabbit has approved the PR",
            "dependencies": [
              4
            ],
            "details": "Modify tasks.markDone mutation in Convex to check if task has prUrl field. If prUrl exists, validate that task.metadata.prStatus === 'approved'. If not approved, throw error 'Cannot complete task until CodeRabbit approves PR'. In UI, disable 'Mark Done' button when task has prUrl and prStatus !== 'approved'. Show tooltip on disabled button: 'Blocked until CodeRabbit approves'. Add conditional check in mutation to allow completion only if no prUrl or prStatus is 'approved'.",
            "status": "pending",
            "testStrategy": "Attempt to mark task done when prStatus is 'pending' and verify error thrown. Confirm 'Mark Done' button is disabled with tooltip. Change prStatus to 'approved' via webhook or manual update and verify button enables. Test task completes successfully when approved."
          },
          {
            "id": 7,
            "title": "Add lock icon UI for unapproved PRs",
            "description": "Display visual lock indicator on tasks blocked by pending CodeRabbit approval",
            "dependencies": [
              6
            ],
            "details": "Add lock icon (LockIcon from lucide-react) overlaying task card when task has prUrl and prStatus !== 'approved'. Position icon in top-right corner with semi-transparent background. Add pulsing animation to draw attention. Include tooltip on hover showing 'Task locked until CodeRabbit approval'. Conditionally render lock based on gating logic. Remove lock icon immediately when prStatus changes to 'approved' via webhook update.",
            "status": "pending",
            "testStrategy": "View task with prUrl and prStatus 'pending' and verify lock icon displays. Hover over lock and confirm tooltip appears. Simulate webhook approval and verify lock icon disappears. Test lock icon positioning and styling on different screen sizes."
          },
          {
            "id": 8,
            "title": "Add filter for PR-linked tasks and pending review count",
            "description": "Implement filter toggle to show only tasks with linked PRs and display count of pending reviews",
            "dependencies": [
              1,
              4
            ],
            "details": "Add toggle button/checkbox labeled 'Show only PR-linked tasks' at top of dev page. Store filter state in component state. Filter task list to show only tasks where prUrl exists when toggle is active. Calculate count of tasks with prStatus === 'pending' or 'changes_requested'. Display count badge at top: 'X pending reviews' in prominent position. Update count dynamically when webhook events update prStatus. Default filter to off (show all tasks). Persist filter preference in localStorage.",
            "status": "pending",
            "testStrategy": "Toggle filter and verify only PR-linked tasks display. Confirm count shows correct number of pending reviews. Test count updates when prStatus changes via webhook. Verify localStorage persists filter state across page reloads."
          }
        ]
      },
      {
        "id": 20,
        "title": "Autumn API integration for AI credit metering",
        "description": "Integrate Autumn API for credit-based billing system to meter AI-powered features like rule summarization",
        "details": "Install axios for API calls. Create app/lib/autumn.ts with functions: getCredits(workspaceId), consumeCredits(workspaceId, amount), addCredits(workspaceId, amount). Call Autumn API endpoints (refer to Autumn docs for latest v1 API): GET /api/v1/credits, POST /api/v1/consume with headers: Authorization: Bearer {AUTUMN_API_KEY}, body: { workspace_id, amount }. Store local credit balance in Convex billing table synced periodically. Create Convex query billing.getBalance(workspaceId) and mutation billing.consume(workspaceId, n) that first checks local balance, then calls Autumn API to consume. If insufficient credits, return error with CTA to purchase. Create app/components/CreditsDisplay.tsx showing current balance with icon. Add to navbar. Implement credit purchase flow: show pricing modal with Autumn payment link or embedded widget. Handle webhook from Autumn on credit purchase to sync billing table. Log all credit transactions to Sentry.",
        "testStrategy": "Initialize workspace with test credits. Consume credits and verify balance decrements. Test insufficient credits returns error with CTA. Verify credit display updates in real-time. Test purchase flow adds credits. Confirm Sentry logs credit transactions.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Autumn API client library and authentication",
            "description": "Install axios and create the Autumn API client module with authentication headers and base configuration for all credit-related API calls",
            "dependencies": [],
            "details": "Install axios@latest via npm/pnpm. Create app/lib/autumn.ts with AutumnClient class or object containing base URL (https://api.autumn.dev or per latest docs), default headers including Authorization: Bearer ${AUTUMN_API_KEY}, and axios instance configuration. Implement error handling wrapper for API calls. Store AUTUMN_API_KEY in environment variables and validate presence on initialization. Add TypeScript types for API request/response shapes.",
            "status": "pending",
            "testStrategy": "Verify axios is installed. Test AutumnClient initialization fails gracefully without API key. Mock API call to verify headers are correctly set. Confirm error handling catches network failures."
          },
          {
            "id": 2,
            "title": "Implement Autumn API credit balance and consumption functions",
            "description": "Create getCredits, consumeCredits, and addCredits functions in autumn.ts that call Autumn API endpoints for credit operations",
            "dependencies": [
              1
            ],
            "details": "In app/lib/autumn.ts, implement getCredits(workspaceId: string) calling GET /api/v1/credits with workspace_id query param, returning current balance. Implement consumeCredits(workspaceId: string, amount: number) calling POST /api/v1/consume with body { workspace_id, amount }, returning updated balance or error. Implement addCredits(workspaceId: string, amount: number) for future admin/webhook use. Add proper TypeScript return types. Handle API errors with specific error codes for insufficient credits vs network failures. Add retry logic with exponential backoff for transient failures.",
            "status": "pending",
            "testStrategy": "Test getCredits returns balance for valid workspace. Test consumeCredits decrements balance and returns success. Test consumeCredits with insufficient credits returns specific error code. Verify retry logic executes on 5xx errors. Mock Autumn API responses for all scenarios."
          },
          {
            "id": 3,
            "title": "Create Convex billing table schema and sync mutations",
            "description": "Define Convex billing table to store local credit balances and implement mutations to sync with Autumn API periodically",
            "dependencies": [
              2
            ],
            "details": "Create convex/billing.ts schema with table billing containing fields: workspaceId (string, indexed), balance (number), lastSyncedAt (number timestamp), autumnTransactionId (optional string). Create mutation billing.syncFromAutumn(workspaceId) that calls autumn.getCredits() and updates local balance and lastSyncedAt. Implement periodic sync via Convex cron job (every 5 minutes) calling syncFromAutumn for active workspaces. Add mutation billing.initialize(workspaceId) for new workspace setup. Handle race conditions with optimistic locking or versioning.",
            "status": "pending",
            "testStrategy": "Verify billing table schema is created in Convex. Test syncFromAutumn updates balance and timestamp. Confirm cron job triggers sync periodically. Test initialize creates billing record for new workspace. Verify concurrent sync calls don't corrupt data."
          },
          {
            "id": 4,
            "title": "Implement credit balance query and atomic consumption mutation",
            "description": "Create Convex query to read local credit balance and mutation to consume credits with atomic checks against both local cache and Autumn API",
            "dependencies": [
              3
            ],
            "details": "Create convex/billing.ts query getBalance(workspaceId: string) returning current balance from local billing table, falling back to sync if stale (>10 min). Create mutation consume(workspaceId: string, amount: number) that: (1) checks local balance >= amount, (2) calls autumn.consumeCredits(workspaceId, amount) to atomically consume on Autumn side, (3) updates local billing table on success, (4) logs transaction to Sentry with workspaceId and amount. On insufficient credits, throw error with code 'INSUFFICIENT_CREDITS' and message containing CTA. Implement idempotency using transaction IDs to prevent double-charging on retries.",
            "status": "pending",
            "testStrategy": "Test getBalance returns current balance. Test consume with sufficient credits decrements balance atomically. Test consume with insufficient local credits calls Autumn API and fails gracefully. Verify INSUFFICIENT_CREDITS error includes CTA message. Test idempotency prevents double consumption on retry. Confirm Sentry logs all consumption events."
          },
          {
            "id": 5,
            "title": "Build insufficient credits error handling with purchase CTA",
            "description": "Implement error handling flow that detects insufficient credits and displays modal with call-to-action to purchase more credits",
            "dependencies": [
              4
            ],
            "details": "Create app/components/InsufficientCreditsModal.tsx that displays when billing.consume throws INSUFFICIENT_CREDITS error. Modal shows current balance, amount needed, and prominent CTA button linking to pricing/purchase flow. Implement useErrorBoundary or error state management in components calling consume mutation to catch and display modal. Add analytics event tracking for insufficient credits errors. Style modal with urgency (warning colors) while remaining accessible. Include 'Learn More' link to credits documentation.",
            "status": "pending",
            "testStrategy": "Trigger consume with insufficient credits and verify modal appears. Confirm modal displays correct balance and needed amount. Test CTA button navigates to purchase flow. Verify modal closes on dismiss. Test analytics event fires on modal display."
          },
          {
            "id": 6,
            "title": "Create credits display UI component and integrate in navbar",
            "description": "Build CreditsDisplay component showing current workspace credit balance with icon and integrate it into the application navbar",
            "dependencies": [
              4
            ],
            "details": "Create app/components/CreditsDisplay.tsx using Convex useQuery hook to call billing.getBalance(currentWorkspaceId). Display balance with coin/credit icon (from lucide-react or similar). Add loading skeleton for initial query. Implement real-time updates via Convex reactive queries. Style component to fit navbar design system. Add hover tooltip showing last sync time. Make component clickable to open credits management page. Handle error states gracefully (show '--' or error icon if balance fails to load). Use optimistic updates if balance changes locally.",
            "status": "pending",
            "testStrategy": "Verify CreditsDisplay renders in navbar with current balance. Test real-time updates when credits are consumed elsewhere. Confirm loading state shows skeleton. Test error state displays fallback UI. Verify hover tooltip shows sync time. Test click navigation to credits page."
          },
          {
            "id": 7,
            "title": "Implement credit purchase flow with Autumn payment integration and webhook handling",
            "description": "Build end-to-end purchase flow with pricing modal, Autumn payment widget integration, and webhook handler to sync credits after successful purchase",
            "dependencies": [
              3,
              5
            ],
            "details": "Create app/components/CreditsPurchaseModal.tsx with pricing tiers (e.g., 10 credits for $5, 50 for $20, 100 for $35). Integrate Autumn payment link or embedded checkout widget per Autumn documentation. Create Convex HTTP endpoint (convex/http.ts) route POST /webhooks/autumn to handle credit purchase webhooks. Validate webhook signature using Autumn secret. Parse webhook payload for workspaceId and credits purchased. Call billing.addCredits mutation to update local balance. Log purchase event to Sentry with transaction details. Add confirmation UI after successful purchase. Implement webhook retry logic and idempotency using Autumn transaction IDs.",
            "status": "pending",
            "testStrategy": "Test pricing modal displays tiers correctly. Verify Autumn payment widget loads and processes test payment. Trigger webhook with test payload and confirm credits are added to billing table. Test webhook signature validation rejects invalid signatures. Verify idempotency prevents duplicate credit additions. Confirm Sentry logs purchase events with full context. Test purchase confirmation UI appears after successful payment."
          }
        ]
      },
      {
        "id": 21,
        "title": "AI-powered rules summarizer with credit gating",
        "description": "Build AI feature that analyzes imported hackathon rules and generates compliance tasks, metered by Autumn credits",
        "details": "Install openai@latest SDK. Create Convex action ai.summarizeRules(importId) that: (1) Checks credits via billing.getBalance(), requires ≥1 credit, (2) Fetches import.raw data from Convex, (3) Calls OpenAI API: POST https://api.openai.com/v1/chat/completions with model: 'gpt-4o-2024-08-06', messages: [{ role: 'system', content: 'You are an expert at hackathon compliance. Analyze the rules and generate 5 actionable compliance tasks.' }, { role: 'user', content: rules text }], response_format: { type: 'json_object' }, (4) Parse JSON response expecting array of { title, description, priority }, (5) Creates tasks with label 'compliance', (6) Calls billing.consume(workspaceId, 1), (7) Returns created task IDs. Create UI button 'Summarize Rules' on import preview or task page. Show modal with credit cost: 'This will use 1 credit. You have X remaining.' On confirm, call action and show loading spinner. Display created tasks in toast notification. Handle errors: insufficient credits shows upgrade CTA, API failure logs to Sentry and shows retry option.",
        "testStrategy": "Click 'Summarize Rules' with sufficient credits and verify 5 compliance tasks are created. Confirm credit balance decrements by 1. Test insufficient credits shows error modal with CTA. Verify AI-generated tasks have relevant titles and compliance label. Test OpenAI API error handling shows retry option.",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install OpenAI SDK and configure API client",
            "description": "Install openai@latest package and set up API client configuration with error handling and retry logic",
            "dependencies": [],
            "details": "Run npm install openai@latest. Create app/lib/openai.ts with OpenAI client initialization using API key from environment variables. Configure client with timeout settings (30s), max retries (3), and error handling. Export configured client instance for use in Convex actions. Add OPENAI_API_KEY to .env and Netlify environment variables.",
            "status": "pending",
            "testStrategy": "Verify openai package is installed in package.json. Test client initialization doesn't throw errors. Confirm environment variable is loaded correctly."
          },
          {
            "id": 2,
            "title": "Create Convex action for AI rule summarization",
            "description": "Implement convex/ai.ts with summarizeRules action that orchestrates the entire AI summarization workflow",
            "dependencies": [
              1
            ],
            "details": "Create convex/ai.ts with action summarizeRules(importId). Import OpenAI client from lib. Define action signature accepting importId parameter. Set up action context with database access. Implement main orchestration logic calling subsequent steps in sequence. Add proper error boundaries and logging with Sentry. Return structured response with created task IDs or error details.",
            "status": "pending",
            "testStrategy": "Call action from Convex dashboard with test importId. Verify action executes without crashing. Confirm proper error logging to Sentry."
          },
          {
            "id": 3,
            "title": "Implement credit balance check before execution",
            "description": "Add credit verification logic that checks workspace has sufficient credits before proceeding with AI call",
            "dependencies": [
              2
            ],
            "details": "In summarizeRules action, call billing.getBalance(workspaceId) before any processing. Require at least 1 credit available. If insufficient credits, throw error with code 'INSUFFICIENT_CREDITS' and message including current balance. Ensure no API calls or credit consumption happens if check fails. Return workspace credit info in error response for UI display.",
            "status": "pending",
            "testStrategy": "Test action with workspace having 0 credits and verify it fails with INSUFFICIENT_CREDITS error. Test with 1+ credits and verify it proceeds. Confirm no credits consumed on failure."
          },
          {
            "id": 4,
            "title": "Implement OpenAI API call with structured JSON output",
            "description": "Make API call to OpenAI chat completions endpoint with system/user prompts and JSON response format configuration",
            "dependencies": [
              3
            ],
            "details": "Fetch import.raw data from Convex database using importId. Call openai.chat.completions.create() with model 'gpt-4o-2024-08-06', messages array containing system prompt 'You are an expert at hackathon compliance. Analyze the rules and generate 5 actionable compliance tasks.' and user prompt with rules text from import.raw. Set response_format to { type: 'json_object' }. Configure temperature: 0.7, max_tokens: 2000. Handle API errors (rate limits, timeouts, invalid responses) with proper error messages.",
            "status": "pending",
            "testStrategy": "Test with sample import data and verify API returns JSON object. Test with invalid import ID and confirm error handling. Verify API timeout handling. Check rate limit error returns retry-able error."
          },
          {
            "id": 5,
            "title": "Parse and validate OpenAI JSON response",
            "description": "Extract task data from AI response, validate structure matches expected schema, and handle malformed outputs",
            "dependencies": [
              4
            ],
            "details": "Parse response.choices[0].message.content as JSON. Validate response contains 'tasks' array with 5 items. Each item must have: title (string, 5-100 chars), description (string, 10-500 chars), priority (enum: 'high'|'medium'|'low'). Use zod schema for validation. If validation fails, log raw response to Sentry and throw error 'INVALID_AI_RESPONSE'. Map priority to task priority field. Sanitize text fields to prevent XSS.",
            "status": "pending",
            "testStrategy": "Test with mock valid JSON response and verify parsing succeeds. Test with malformed JSON and verify error thrown. Test with missing fields and confirm validation catches it. Verify XSS sanitization works."
          },
          {
            "id": 6,
            "title": "Create compliance tasks from AI-generated output",
            "description": "Insert parsed AI tasks into Convex tasks table with compliance label and proper workspace/source attribution",
            "dependencies": [
              5
            ],
            "details": "For each validated task object, call tasks.create mutation with: workspaceId from import, title and description from AI output, status: 'pending', priority from AI output, labels: ['compliance'], source: { type: 'ai', importId, model: 'gpt-4o-2024-08-06' }, createdAt: Date.now(). Batch insert all 5 tasks in single transaction if possible. Collect created task IDs. If any task creation fails, rollback all and throw error.",
            "status": "pending",
            "testStrategy": "Verify 5 tasks are created with correct fields. Confirm all have 'compliance' label. Test tasks are linked to correct workspace. Verify source metadata is saved. Test transaction rollback on failure."
          },
          {
            "id": 7,
            "title": "Consume credit after successful task creation",
            "description": "Call billing.consume to deduct 1 credit from workspace balance only after all tasks successfully created",
            "dependencies": [
              6
            ],
            "details": "After all tasks created successfully, call billing.consume(workspaceId, 1) mutation. Only consume credit if entire operation succeeded (credit check passed, API called, tasks created). If consume fails, log error to Sentry but don't rollback tasks since work was completed. Update local billing table balance. Return success response with created task IDs and new credit balance.",
            "status": "pending",
            "testStrategy": "Verify credit balance decrements by exactly 1 after successful run. Test credit is not consumed if task creation fails. Confirm billing table updates correctly. Test consume failure is logged but doesn't fail action."
          },
          {
            "id": 8,
            "title": "Build UI button with confirmation modal and error handling",
            "description": "Create 'Summarize Rules' button with credit cost confirmation modal, loading states, and comprehensive error handling",
            "dependencies": [
              7
            ],
            "details": "Add 'Summarize Rules' button to import preview page (app/routes/import.tsx). On click, fetch current credit balance and show modal: 'This will use 1 credit. You have X remaining. Continue?' with Cancel/Confirm buttons. On confirm, call ai.summarizeRules action with loading spinner overlay. On success, show toast 'Created 5 compliance tasks!' with links to tasks. Handle errors: INSUFFICIENT_CREDITS shows upgrade modal with pricing CTA linking to billing page, API errors show retry button, other errors log to Sentry and show generic error message. Disable button while loading.",
            "status": "pending",
            "testStrategy": "Click button with sufficient credits and verify modal shows correct balance. Confirm action executes and toast appears with task links. Test insufficient credits shows upgrade CTA. Test API error shows retry option. Verify button disabled state during loading."
          }
        ]
      },
      {
        "id": 22,
        "title": "Public read-only workspace sharing",
        "description": "Implement shareable public links for workspaces with read-only access to dashboard, tasks, and calendar without authentication",
        "details": "Add 'isPublic' boolean and 'publicSlug' string fields to workspaces table. Create Convex mutation workspaces.enablePublicSharing(workspaceId) that generates unique publicSlug using nanoid(10) and sets isPublic=true. Add mutation workspaces.disablePublicSharing(workspaceId) that sets isPublic=false. Create app/routes/share/$slug.tsx route that queries workspace by publicSlug, verifies isPublic=true, then renders read-only views. Reuse components from dashboard, tasks, calendar but disable all mutations (no add/edit/delete). Hide user-specific UI (avatars, comments input, presence). Add banner at top: 'You are viewing a shared workspace. Sign in to collaborate.' with CTA button. Create 'Share' button in workspace settings that shows public link: https://hackpack.app/share/{publicSlug} with copy button. Add toggle to enable/disable sharing. Show warning: 'Anyone with this link can view your workspace.' Implement OpenGraph meta tags for link previews.",
        "testStrategy": "Enable public sharing and verify publicSlug generates. Visit /share/{slug} without auth and confirm dashboard, tasks, calendar load. Test mutation buttons are hidden/disabled. Verify toggle off makes link return 404. Test OpenGraph preview shows workspace name. Confirm copy button copies correct URL.",
        "priority": "medium",
        "dependencies": [
          6,
          14,
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add isPublic and publicSlug fields to workspaces schema",
            "description": "Extend the workspaces table schema to include isPublic boolean field (default false) and publicSlug string field (nullable) for public sharing functionality",
            "dependencies": [],
            "details": "In convex/schema.ts or convex/workspaces.ts schema definition, add two new fields to the workspaces table: 'isPublic' as v.boolean() with default value false, and 'publicSlug' as v.union(v.string(), v.null()) with default null. Ensure the schema migration is applied correctly. The publicSlug should be indexed for efficient lookups when accessing public share URLs.",
            "status": "pending",
            "testStrategy": "Verify schema migration completes successfully. Create a workspace and confirm isPublic defaults to false and publicSlug defaults to null. Query the workspaces table to validate new fields exist."
          },
          {
            "id": 2,
            "title": "Implement enablePublicSharing mutation with unique slug generation",
            "description": "Create a Convex mutation that enables public sharing for a workspace by generating a unique publicSlug using nanoid and setting isPublic to true",
            "dependencies": [
              1
            ],
            "details": "In convex/workspaces.ts, create mutation enablePublicSharing(workspaceId) that verifies the caller has owner permissions using isWorkspaceOwner helper. Generate a unique 10-character slug using nanoid(10). Check for slug uniqueness by querying workspaces with the generated slug; regenerate if collision occurs (max 3 attempts). Update the workspace document to set isPublic=true and publicSlug=generated slug. Return the publicSlug to the caller.",
            "status": "pending",
            "testStrategy": "Call enablePublicSharing mutation and verify publicSlug is generated and stored. Confirm isPublic is set to true. Test that non-owners cannot enable sharing. Verify slug uniqueness by enabling sharing on multiple workspaces."
          },
          {
            "id": 3,
            "title": "Implement disablePublicSharing mutation",
            "description": "Create a Convex mutation that disables public sharing for a workspace by setting isPublic to false while preserving the publicSlug",
            "dependencies": [
              1
            ],
            "details": "In convex/workspaces.ts, create mutation disablePublicSharing(workspaceId) that verifies the caller has owner permissions. Update the workspace document to set isPublic=false. Optionally keep publicSlug intact to allow re-enabling without regenerating the slug, or set it to null based on requirements. Return success status.",
            "status": "pending",
            "testStrategy": "Enable sharing on a workspace, then disable it and verify isPublic is false. Attempt to access the public share URL and confirm it returns 404 or access denied. Test that non-owners cannot disable sharing."
          },
          {
            "id": 4,
            "title": "Create public share route with slug lookup and access validation",
            "description": "Implement app/routes/share/$slug.tsx route that queries workspace by publicSlug, validates isPublic is true, and renders the public view",
            "dependencies": [
              2,
              3
            ],
            "details": "Create new route file app/routes/share/$slug.tsx. In the loader function, extract the slug parameter and query Convex for a workspace where publicSlug matches and isPublic is true. If not found or isPublic is false, return 404. If valid, fetch necessary workspace data (name, dashboard items, tasks, calendar events) using read-only queries. Pass workspace data to the component. Implement error handling for invalid slugs or disabled sharing.",
            "status": "pending",
            "testStrategy": "Enable sharing on a workspace and visit /share/{publicSlug} without authentication. Verify workspace content loads. Disable sharing and confirm the URL returns 404. Test with invalid slug and verify 404 response."
          },
          {
            "id": 5,
            "title": "Create read-only component variants with disabled mutations",
            "description": "Develop read-only versions of dashboard, tasks, and calendar components that disable all mutation actions (add, edit, delete) for public sharing view",
            "dependencies": [
              4
            ],
            "details": "Create new components or add read-only prop to existing dashboard, tasks, and calendar components. Conditionally hide or disable buttons for adding, editing, or deleting content. Remove mutation calls (onClick handlers that trigger Convex mutations). Hide user-specific UI elements like avatars, comment inputs, presence indicators, and action menus. Ensure data is displayed correctly but all interactive mutation features are disabled. Consider creating wrapper components like ReadOnlyDashboard, ReadOnlyTaskList, ReadOnlyCalendar.",
            "status": "pending",
            "testStrategy": "View public share URL and verify all mutation buttons (add task, edit, delete) are hidden or disabled. Confirm data displays correctly. Test that attempting to trigger mutations via browser console fails gracefully. Verify user-specific elements are not visible."
          },
          {
            "id": 6,
            "title": "Add public view banner with sign-in CTA",
            "description": "Create a banner component displayed at the top of public share views indicating read-only status and prompting users to sign in for collaboration",
            "dependencies": [
              4
            ],
            "details": "Create app/components/PublicViewBanner.tsx component with message: 'You are viewing a shared workspace. Sign in to collaborate.' Include a CTA button that redirects to the login/signup page with a returnUrl parameter to redirect back after authentication. Style the banner distinctively (e.g., blue/info background) to clearly indicate public view mode. Position banner at the top of the share route layout.",
            "status": "pending",
            "testStrategy": "Visit a public share URL and verify the banner appears at the top. Click the CTA button and confirm it redirects to login page. Verify returnUrl parameter is set correctly. Test banner styling is visually distinct."
          },
          {
            "id": 7,
            "title": "Build share settings UI with toggle and copy link functionality",
            "description": "Create workspace settings interface with public sharing toggle, public link display, and copy-to-clipboard functionality with appropriate warnings",
            "dependencies": [
              2,
              3
            ],
            "details": "In workspace settings page/component, add a 'Public Sharing' section. Include a toggle switch to enable/disable public sharing that calls enablePublicSharing or disablePublicSharing mutations. When enabled, display the public link: https://hackpack.app/share/{publicSlug} in a read-only input field with a copy button using navigator.clipboard.writeText(). Show warning message: 'Anyone with this link can view your workspace.' Use toast/notification on successful copy. Only show toggle to workspace owners.",
            "status": "pending",
            "testStrategy": "Toggle public sharing on and verify publicSlug is generated and link is displayed. Click copy button and verify link is copied to clipboard. Toggle off and confirm link is no longer accessible. Test that non-owners cannot see or use the toggle."
          },
          {
            "id": 8,
            "title": "Implement OpenGraph meta tags for share link previews",
            "description": "Add OpenGraph meta tags to the public share route for rich link previews when shared on social media or messaging platforms",
            "dependencies": [
              4
            ],
            "details": "In app/routes/share/$slug.tsx, use TanStack Start's meta function or head tags to inject OpenGraph meta tags. Include og:title (workspace name), og:description (e.g., 'View this shared workspace on HackPack'), og:type ('website'), og:url (full share URL), og:image (optional workspace thumbnail or app logo). Also add twitter:card meta tags for Twitter previews. Ensure meta tags are rendered server-side for proper preview generation by social platforms.",
            "status": "pending",
            "testStrategy": "Share a public workspace URL on platforms like Slack, Discord, or Twitter and verify rich preview appears with workspace name and description. Use OpenGraph debugging tools (Facebook Debugger, Twitter Card Validator) to validate meta tags are correctly rendered."
          }
        ]
      },
      {
        "id": 23,
        "title": "Sponsor usage documentation page",
        "description": "Create auto-generated sponsor usage checklist page that documents how each hackathon sponsor technology is integrated in the application",
        "details": "Create app/routes/sponsors.tsx static page with sponsor integration matrix. For each sponsor, show: logo (optional), integration description, code references with file paths and line numbers, acceptance criteria checklist with checkboxes. Structure data: TanStack Start (streaming logs in import.ts:45, server functions in api/), Convex (schema in convex/schema.ts, live queries in tasks.tsx:78), Netlify (netlify.toml, environment config), Firecrawl (extraction in lib/firecrawl.ts:23), Sentry (error tracking in lib/sentry.server.ts:12, performance in import action), Autumn (credit metering in lib/autumn.ts:34), Cloudflare (Turnstile in components/TurnstileWidget.tsx:15, optional Workers AI), CodeRabbit (PR gating in webhooks/github.ts:67). Add acceptance criteria per sponsor from PRD section 14. Create 'Verify Integration' checklist with manual checkboxes (stored in localStorage). Add 'Generate Report' button that exports checklist as markdown for submission. Include links to live demos of each integration. Make page accessible via /sponsors and add to footer.",
        "testStrategy": "Visit /sponsors page and verify all 8 sponsors are listed. Confirm code references link to correct files. Test checkboxes persist in localStorage. Verify 'Generate Report' exports markdown with checked items. Confirm acceptance criteria match PRD requirements.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sponsors route and base page structure",
            "description": "Set up app/routes/sponsors.tsx with route configuration, page layout, header, and footer navigation link",
            "dependencies": [],
            "details": "Create app/routes/sponsors.tsx as a new TanStack Start route. Define the route component with basic page structure including header 'Sponsor Integration Documentation' and container layout. Add responsive grid/flex layout for sponsor cards. Update footer component to include /sponsors link in navigation menu. Apply consistent styling with existing app theme.",
            "status": "pending",
            "testStrategy": "Navigate to /sponsors and verify page renders with header. Confirm footer link navigates correctly. Test responsive layout on mobile and desktop viewports."
          },
          {
            "id": 2,
            "title": "Define sponsor integration data structure with code references",
            "description": "Create comprehensive data structure documenting all 8 sponsor technologies with integration points, file paths, and line numbers",
            "dependencies": [
              1
            ],
            "details": "Create sponsors data object with entries for: TanStack Start (streaming logs in import.ts:45, server functions), Convex (schema in convex/schema.ts, live queries in tasks.tsx:78), Netlify (netlify.toml config), Firecrawl (extraction lib/firecrawl.ts:23), Sentry (tracking lib/sentry.server.ts:12, performance in import action), Autumn (metering lib/autumn.ts:34), Cloudflare (Turnstile components/TurnstileWidget.tsx:15, Workers AI optional), CodeRabbit (webhooks/github.ts:67). Each entry includes: name, logo path (optional), description, codeReferences array with {file, line, description}, and acceptanceCriteria array from PRD section 14.",
            "status": "pending",
            "testStrategy": "Verify all 8 sponsors have complete data entries. Confirm code references match actual file paths and line numbers in codebase. Validate acceptance criteria align with PRD section 14 requirements."
          },
          {
            "id": 3,
            "title": "Build sponsor card UI with acceptance criteria checklist",
            "description": "Create reusable sponsor card component displaying integration details, code references, and interactive acceptance criteria checkboxes",
            "dependencies": [
              2
            ],
            "details": "Create SponsorCard component accepting sponsor data prop. Render sponsor logo (if provided), name, and integration description. Display code references as clickable links showing file:line format. Implement acceptance criteria section with checkboxes for each criterion. Add onChange handlers that update checkbox state and persist to localStorage using key pattern 'sponsor-checklist-{sponsorName}-{criteriaIndex}'. Load initial checkbox states from localStorage on mount. Style cards with borders, shadows, and proper spacing.",
            "status": "pending",
            "testStrategy": "Check/uncheck acceptance criteria and verify state persists in localStorage after page reload. Confirm code reference links display correctly. Test card layout with and without logo images. Verify all checkboxes function independently."
          },
          {
            "id": 4,
            "title": "Implement markdown export functionality for submission report",
            "description": "Add 'Generate Report' button that exports current checklist state as formatted markdown document",
            "dependencies": [
              3
            ],
            "details": "Create generateMarkdownReport() function that reads all sponsor checklist states from localStorage. Build markdown string with structure: '# Sponsor Integration Report', date timestamp, sections per sponsor with '## {Sponsor Name}', integration description, code references as bullet list, acceptance criteria with [x] or [ ] based on checkbox state. Add 'Generate Report' button to page footer/header. Implement download functionality using Blob and URL.createObjectURL to save as sponsors-report.md. Include summary statistics (total criteria, completed count).",
            "status": "pending",
            "testStrategy": "Click 'Generate Report' and verify markdown file downloads. Open file and confirm formatting matches expected structure. Test with various checkbox combinations. Verify checked items show [x] and unchecked show [ ]. Confirm all 8 sponsors appear in report with accurate data."
          },
          {
            "id": 5,
            "title": "Add live demo links and finalize page integration",
            "description": "Include links to live demonstrations of each sponsor integration and ensure page accessibility",
            "dependencies": [
              4
            ],
            "details": "Add demoLinks array to sponsor data structure with URLs to working examples: import streaming demo, Convex live query demo, Sentry error test endpoint, Turnstile widget demo, etc. Render demo links in each sponsor card with 'View Live Demo' buttons. Ensure /sponsors route is publicly accessible without authentication. Add meta tags for page title and description. Test footer link visibility and accessibility. Verify all interactive elements have proper ARIA labels and keyboard navigation support.",
            "status": "pending",
            "testStrategy": "Click each 'View Live Demo' link and verify it navigates to working demonstration. Test keyboard navigation through all checkboxes and buttons. Verify page is accessible via /sponsors without login. Confirm meta tags render correctly. Test screen reader compatibility with ARIA labels."
          }
        ]
      },
      {
        "id": 24,
        "title": "Settings page with API tokens and health monitoring",
        "description": "Build settings interface for managing API keys, workspace configuration, and monitoring service health status",
        "details": "Create app/routes/settings.tsx with tabbed interface: General, Integrations, Team, Billing. General tab: workspace name input, slug input, danger zone with delete workspace button. Integrations tab: display configured API keys with masked values (show last 4 chars), test connection buttons for each service (Firecrawl, Autumn, Sentry), show status badges (Connected=green, Error=red, Not Configured=gray). Add 'Test Firecrawl' that makes sample API call, 'Test Turnstile' that validates secret with dummy token. Show Sentry health: link to project dashboard, display error count from last 24h via Sentry API. Team tab: list workspace members from memberships table, show role badges, add 'Invite Member' input with email and role selector, implement invite link generation. Billing tab: show current Autumn credits with usage chart (last 7 days), add 'Purchase Credits' button linking to Autumn. Store sensitive tokens in Convex environment or encrypted fields (never in client). Implement settings validation and error messages.",
        "testStrategy": "Update workspace name and verify it saves. Test API key validation shows connection status. Confirm test buttons execute successfully for configured services. Verify Sentry health displays correct error count. Test member invite creates shareable link. Confirm billing tab shows accurate credit balance.",
        "priority": "medium",
        "dependencies": [
          8,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create settings route with tabbed layout structure",
            "description": "Implement app/routes/settings.tsx with tabbed navigation supporting General, Integrations, Team, and Billing tabs",
            "dependencies": [],
            "details": "Create settings.tsx route file with TanStack Router. Implement TabNavigation component with four tabs: General, Integrations, Team, Billing. Use state management to track active tab. Set up routing structure to support /settings?tab=general pattern. Create container layout with sidebar navigation and content area. Style tabs with active state indicators. Ensure responsive design for mobile views.",
            "status": "pending",
            "testStrategy": "Verify all four tabs render and are clickable. Test tab switching updates URL query params. Confirm active tab styling applies correctly. Test responsive layout on mobile breakpoints."
          },
          {
            "id": 2,
            "title": "Implement General tab with workspace configuration",
            "description": "Build General tab interface with workspace name input, slug input, and danger zone for workspace deletion",
            "dependencies": [
              1
            ],
            "details": "Create GeneralTab component with controlled form inputs for workspace name and slug. Implement Convex mutation workspaces.update(id, {name, slug}) for saving changes. Add real-time validation for slug uniqueness using Convex query. Create danger zone section with red-themed UI containing 'Delete Workspace' button. Implement confirmation modal for deletion with workspace name verification input. Connect to workspaces.delete(id) mutation. Show success/error toasts. Add auto-save debouncing for name/slug fields.",
            "status": "pending",
            "testStrategy": "Update workspace name and verify it saves to Convex. Test slug validation rejects duplicates. Confirm delete button shows confirmation modal. Verify workspace deletion succeeds and redirects appropriately. Test auto-save triggers after typing stops."
          },
          {
            "id": 3,
            "title": "Build Integrations tab with masked API key display",
            "description": "Create Integrations tab showing configured API keys with masked values and service status badges",
            "dependencies": [
              1
            ],
            "details": "Create IntegrationsTab component displaying configured services: Firecrawl, Autumn, Turnstile, Sentry. For each service, show masked API key (last 4 chars visible, rest as asterisks). Display status badge using color coding: Connected=green, Error=red, Not Configured=gray. Create Convex query workspaces.getIntegrations(workspaceId) returning configured services. Store API keys in Convex environment variables or encrypted workspace fields. Implement AddAPIKeyModal for configuring new services. Create form inputs for each service type with validation. Use zod schema for API key format validation.",
            "status": "pending",
            "testStrategy": "Verify API keys display with only last 4 characters visible. Test status badges show correct colors based on configuration state. Confirm Add API Key modal opens and saves correctly. Test masking works for keys of different lengths."
          },
          {
            "id": 4,
            "title": "Implement service connection testing functionality",
            "description": "Add test connection buttons for Firecrawl, Turnstile, and Sentry with real API validation calls",
            "dependencies": [
              3
            ],
            "details": "Create Convex actions integrations.testFirecrawl(apiKey) making sample API call to Firecrawl /v1/scrape endpoint with test URL. Implement integrations.testTurnstile(secretKey) validating with dummy token against Cloudflare siteverify endpoint. Create integrations.testSentry(dsn) by sending test event and checking response. Add loading states and result indicators next to each test button. Show success message with checkmark or error message with details. Implement error capture and logging to Sentry for failed tests. Add rate limiting to prevent abuse of test endpoints. Display last test timestamp and result status.",
            "status": "pending",
            "testStrategy": "Click 'Test Firecrawl' with valid key and verify success message. Test with invalid key and confirm error displays. Verify 'Test Turnstile' validates secret correctly. Confirm 'Test Sentry' sends event visible in Sentry dashboard. Test rate limiting prevents rapid repeated tests."
          },
          {
            "id": 5,
            "title": "Integrate Sentry health dashboard and metrics display",
            "description": "Create Sentry health monitoring section showing error counts, project link, and 24-hour statistics",
            "dependencies": [
              3
            ],
            "details": "Implement Convex action integrations.getSentryHealth(projectId) calling Sentry API /api/0/projects/{org}/{project}/stats/ endpoint with auth token. Retrieve error count from last 24 hours. Create SentryHealthCard component displaying: project name, direct link to Sentry dashboard, error count with trend indicator, timestamp of last error. Add visual chart showing error distribution over 24 hours using lightweight charting library. Implement caching mechanism to avoid excessive API calls (5-minute cache). Show loading skeleton while fetching. Handle API errors gracefully with fallback message.",
            "status": "pending",
            "testStrategy": "Verify Sentry health card displays correct error count from API. Test link to Sentry dashboard opens correct project. Confirm 24-hour chart renders with accurate data points. Test caching prevents redundant API calls within 5 minutes. Verify error handling shows appropriate message on API failure."
          },
          {
            "id": 6,
            "title": "Build Team tab with member management interface",
            "description": "Implement Team tab displaying workspace members, roles, and invite functionality with shareable links",
            "dependencies": [
              1
            ],
            "details": "Create TeamTab component querying memberships table joined with users. Display member list showing avatar, name, email, and role badge (Owner/Admin/Member). Implement role color coding: Owner=purple, Admin=blue, Member=gray. Add 'Invite Member' section with email input and role selector dropdown. Create Convex mutation memberships.createInvite(workspaceId, email, role) generating unique invite token using nanoid(32). Store invites in invitations table with expiration timestamp (7 days). Implement invite link generation: /invite/{token}. Add copy-to-clipboard button for invite links. Show active invitations list with revoke option. Create memberships.updateRole(membershipId, newRole) mutation for role changes (Owner only).",
            "status": "pending",
            "testStrategy": "Verify member list displays all workspace members with correct roles. Test invite generation creates valid link. Confirm copy button copies correct URL. Test invite link in new browser session successfully adds member. Verify role selector only shows appropriate options. Test role update mutation changes member role correctly."
          },
          {
            "id": 7,
            "title": "Create Billing tab with Autumn credit usage visualization",
            "description": "Implement Billing tab showing current Autumn credits, 7-day usage chart, and purchase credits functionality",
            "dependencies": [
              1
            ],
            "details": "Create BillingTab component with Convex query billing.getCreditBalance(workspaceId) returning current Autumn credit balance. Implement billing.getUsageHistory(workspaceId, days: 7) returning daily credit consumption. Use charting library (recharts or tremor) to display 7-day usage trend as line or bar chart. Add credit balance card showing remaining credits with visual indicator (green >100, yellow 50-100, red <50). Implement 'Purchase Credits' button linking to Autumn dashboard with workspace identifier. Create usage breakdown by feature: web scraping, AI processing, storage. Add estimated depletion date based on current usage rate. Show transaction history table with date, description, amount.",
            "status": "pending",
            "testStrategy": "Verify credit balance displays accurate current value. Test 7-day usage chart renders with correct data points. Confirm color indicators change based on credit thresholds. Test 'Purchase Credits' link opens Autumn with correct workspace context. Verify usage breakdown sums to total consumption. Test transaction history loads and displays chronologically."
          },
          {
            "id": 8,
            "title": "Implement settings validation and error handling",
            "description": "Add comprehensive validation, error messages, and security measures across all settings tabs",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Implement zod schemas for all settings forms: workspace name/slug validation, API key format validation, email validation for invites, role enum validation. Create unified error toast system with descriptive messages. Add field-level error display with red borders and helper text. Implement server-side validation in all Convex mutations to prevent malicious inputs. Add rate limiting to sensitive operations: delete workspace (1/hour), invite members (10/hour), test connections (5/minute). Sanitize all user inputs to prevent XSS. Validate API keys never expose in client code using server-only actions. Add audit logging for critical changes: role updates, API key modifications, workspace deletion. Create optimistic UI updates with rollback on error. Implement permission checks ensuring only owners can delete workspace or change member roles.",
            "status": "pending",
            "testStrategy": "Test workspace name with invalid characters shows validation error. Verify API key input rejects malformed values. Confirm rate limiting blocks excessive requests. Test permission checks prevent non-owners from restricted actions. Verify error messages are user-friendly and actionable. Test optimistic updates roll back correctly on server error. Confirm audit logs capture critical operations."
          }
        ]
      },
      {
        "id": 25,
        "title": "Demo preparation and hackathon submission package",
        "description": "Create comprehensive demo script, record video demonstration, finalize Vibe Apps submission, and prepare social media launch",
        "details": "Implement demo script from PRD section 20: (1) Prepare sample event URL (TanStack Start Hackathon page), (2) Record screen showing import flow with Turnstile, streaming logs, task/event creation, (3) Demonstrate real-time collaboration in split screen (two browser tabs), (4) Show PR linking and CodeRabbit approval flow with status chip update, (5) Display calendar with ICS subscription, (6) Trigger AI summarizer showing credit decrement and task creation, (7) Show Sentry dashboard with traces and captured error, (8) Visit /sponsors page showing integration checklist, (9) Copy public share link and open in incognito. Record using OBS Studio or Loom, max 90 seconds. Upload to YouTube/Vimeo. Create Vibe Apps submission: fill metadata (name: HackPack, tagline, description, tech stack), add `tanstackstart` tag, upload video link, add public URL (Netlify deployment), include GitHub repo link. Prepare social posts for X/LinkedIn with @mentions: @tan_stack, @convex_dev, @coderabbitai, @firecrawl_dev, @netlify, @autumnpricing, @Cloudflare, @getsentry. Include screenshots and video link. Schedule for submission day Nov 17.",
        "testStrategy": "Rehearse demo script end-to-end within 90 seconds. Verify video quality and audio clarity. Confirm Vibe Apps submission form accepts all metadata. Test public URL loads correctly. Verify social posts include all required handles and hashtags. Confirm submission before 12:00 PM PT deadline.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          7,
          9,
          11,
          12,
          14,
          15,
          16,
          17,
          19,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Prepare demo script and sample event URL",
            "description": "Create detailed demo script following PRD section 20 sequence and prepare TanStack Start Hackathon event URL as sample data",
            "dependencies": [],
            "details": "Write demo script covering all 9 demo points in sequence: import flow, collaboration, PR linking, calendar, AI summarizer, Sentry, sponsors page, public sharing. Ensure script fits 90-second constraint with timing for each section. Locate and bookmark TanStack Start Hackathon event page URL. Prepare any sample data needed (GitHub PR URLs, test user accounts). Create rehearsal checklist to verify all features are working before recording.",
            "status": "pending",
            "testStrategy": "Rehearse script end-to-end with timer, confirming all transitions complete within 90 seconds. Verify sample event URL loads and contains sufficient data for import demo."
          },
          {
            "id": 2,
            "title": "Configure screen recording setup with OBS Studio or Loom",
            "description": "Set up screen recording software with appropriate resolution, audio capture, and browser window configuration for demo recording",
            "dependencies": [
              1
            ],
            "details": "Install OBS Studio or configure Loom account. Set recording resolution to 1920x1080 for optimal YouTube quality. Configure audio capture for system sounds and microphone narration. Set up browser window dimensions for clear visibility of UI elements. Test recording a 10-second clip to verify quality, audio sync, and file size. Configure output settings for direct YouTube upload compatibility (MP4 format, H.264 codec).",
            "status": "pending",
            "testStrategy": "Record test clip and verify video quality, audio clarity, and proper screen capture boundaries. Confirm file format is YouTube-compatible and file size is reasonable for 90-second duration."
          },
          {
            "id": 3,
            "title": "Record import flow with Turnstile and streaming logs",
            "description": "Capture screen recording of event URL import showing Cloudflare Turnstile verification, Firecrawl extraction, and streaming log output with task/event creation",
            "dependencies": [
              2
            ],
            "details": "Navigate to import page, paste TanStack Start Hackathon URL, complete Turnstile challenge. Record streaming logs appearing in real-time showing Firecrawl extraction progress. Capture task and event creation notifications. Show tasks appearing in workspace with proper categorization (deadlines, compliance, social). Ensure logs are visible and legible in recording. Timing target: 15-20 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Review recording segment to verify Turnstile completion is visible, streaming logs are legible, and task creation is clearly demonstrated. Confirm timing fits within allocated segment."
          },
          {
            "id": 4,
            "title": "Demonstrate real-time collaboration in split screen",
            "description": "Record split-screen demonstration showing two browser tabs with real-time updates via Convex live queries when tasks are modified",
            "dependencies": [
              3
            ],
            "details": "Open two browser windows side-by-side (incognito + normal, or two user accounts). Arrange windows for split-screen recording. In one window, create or update a task. Show task immediately appearing/updating in second window without refresh. Demonstrate live query reactivity. Optionally show concurrent editing scenario if time permits. Timing target: 10-12 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Verify both browser windows are clearly visible in recording. Confirm real-time update is obvious and occurs within 1-2 seconds. Check that timing fits within segment allocation."
          },
          {
            "id": 5,
            "title": "Record PR linking and CodeRabbit approval flow",
            "description": "Capture GitHub PR linking to task, CodeRabbit webhook processing, and status chip update showing approval status in task UI",
            "dependencies": [
              4
            ],
            "details": "Open task detail view with PR URL field. Paste GitHub PR link (prepare sample PR beforehand with CodeRabbit approval). Show webhook processing indicator. Demonstrate status chip updating to show CodeRabbit approval status (approved/needs changes). Show PR metadata displayed in task card. Timing target: 10-12 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Verify PR link paste triggers webhook processing. Confirm status chip visibly updates in recording. Ensure CodeRabbit approval status is clearly shown. Check segment timing."
          },
          {
            "id": 6,
            "title": "Display calendar with ICS subscription and AI summarizer demo",
            "description": "Show calendar view with events, demonstrate ICS subscription link, and trigger AI summarizer showing credit decrement and automated task creation",
            "dependencies": [
              5
            ],
            "details": "Navigate to calendar view showing imported events with proper dates. Display ICS subscription URL and briefly show how to copy it. Trigger AI summarizer on a task or event (ensure Autumn AI credits are available). Show credit count decrementing in real-time. Display AI-generated summary appearing and automated task creation from summary. Timing target: 15-18 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Verify calendar displays events correctly with readable dates. Confirm ICS URL is visible. Validate AI summarizer shows credit decrement and creates task. Check timing fits allocation."
          },
          {
            "id": 7,
            "title": "Showcase Sentry dashboard with traces and captured errors",
            "description": "Switch to Sentry dashboard showing performance traces from demo actions and a captured error with source map resolution",
            "dependencies": [
              6
            ],
            "details": "Open Sentry dashboard in new tab. Show performance traces from recent import flow action with transaction details. Display captured error (trigger test error if needed) with full stack trace and source map resolution showing original TypeScript code. Highlight breadcrumbs and context data. Timing target: 8-10 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Confirm Sentry dashboard displays recent traces. Verify captured error shows resolved source maps. Check that key Sentry features (traces, errors, breadcrumbs) are visible in recording."
          },
          {
            "id": 8,
            "title": "Walk through sponsors page integration checklist",
            "description": "Navigate to /sponsors page showing all 8 sponsor integrations with code references and acceptance criteria checkboxes",
            "dependencies": [
              7
            ],
            "details": "Visit /sponsors route. Show sponsor integration matrix with all 8 sponsors (TanStack Start, Convex, Netlify, Firecrawl, Sentry, Autumn, Cloudflare, CodeRabbit). Scroll through code references showing file paths and line numbers. Demonstrate acceptance criteria checkboxes. Optionally show 'Generate Report' button. Timing target: 8-10 seconds for this segment.",
            "status": "pending",
            "testStrategy": "Verify all 8 sponsors are visible in recording. Confirm code references and checkboxes are legible. Check timing fits within segment allocation."
          },
          {
            "id": 9,
            "title": "Demonstrate public share link in incognito mode",
            "description": "Copy public workspace share link, open in incognito browser, and show read-only view of workspace with all tasks and events visible",
            "dependencies": [
              8
            ],
            "details": "Navigate to workspace settings or share dialog. Copy public share link to clipboard (show copy action). Open new incognito browser window. Paste and navigate to public URL. Show read-only workspace view with tasks, events, and calendar accessible without authentication. Timing target: 6-8 seconds for this segment. Confirm total demo time is under 90 seconds.",
            "status": "pending",
            "testStrategy": "Verify public share link copies visibly. Confirm incognito window shows read-only workspace. Validate total recording duration is 90 seconds or less."
          },
          {
            "id": 10,
            "title": "Finalize Vibe Apps submission and prepare social media posts",
            "description": "Complete Vibe Apps submission form with all metadata, upload video link, and create scheduled social media posts for X and LinkedIn with required mentions",
            "dependencies": [
              9
            ],
            "details": "Upload video to YouTube or Vimeo and obtain public link. Fill Vibe Apps submission: name 'HackPack', tagline, description, tech stack, add `tanstackstart` tag. Add video link, public URL (Netlify deployment), GitHub repo link. Prepare X/LinkedIn posts with @mentions: @tan_stack, @convex_dev, @coderabbitai, @firecrawl_dev, @netlify, @autumnpricing, @Cloudflare, @getsentry. Include screenshots and video link. Schedule posts for Nov 17 submission day. Submit before 12:00 PM PT deadline.",
            "status": "pending",
            "testStrategy": "Verify Vibe Apps submission form accepts all fields without errors. Confirm video link, public URL, and GitHub link are accessible. Validate social posts include all 8 required mentions and video link. Confirm submission timestamp is before Nov 17 12:00 PM PT deadline."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-09T10:31:00.254Z",
      "updated": "2025-11-09T11:57:09.584Z",
      "description": "Tasks for master context"
    }
  }
}